[{"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 1, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 1 de 45   II/DAS    REFACTORIZACIÓN    El término refactorización (refactoring) se atribuye a Opdyke, quien lo introdujo por primera  vez en 1992. Una refactorización es una transformación parametrizada de un programa  preservando su comportamiento, que automáticamente modifica el diseño de la aplicación y el  código fuente subyacente. Solo los cambios realizados en el software para hacerlo más fácil de  modificar y comprender son refactorizaciones, por lo que no es una optimización del código, ya  que esto en ocasiones lo hace menos comprensible, ni tampoco el solucionar errores o mejorar  algoritmos. "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 1, "text": "dificar y comprender son refactorizaciones, por lo que no es una optimización del código, ya  que esto en ocasiones lo hace menos comprensible, ni tampoco el solucionar errores o mejorar  algoritmos. Típicamente, una refactorización es una transformación simple que tiene un fácil  pero no trivial impacto en el código fuente de una aplicación.    Por lo tanto, refactorizar un software es modificar su estructura interna con el objeto de que  sea más fácil de entender y de modificar a futuro, tal que el comportamiento observable del  software al ejecutarse no se vea afectado. (Fowler)    Uno de los pilares de cualquiera de las prácticas que forman parte de la técnica es no modificar  el comportamiento externo de la aplicación, para lo que en muchas ocasiones se hace uso de  las pruebas unitar"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 1, "text": "os pilares de cualquiera de las prácticas que forman parte de la técnica es no modificar  el comportamiento externo de la aplicación, para lo que en muchas ocasiones se hace uso de  las pruebas unitarias. La esencia de esta técnica consiste en aplicar una serie de pequeños  cambios en el código manteniendo su comportamiento. Cada uno de estos cambios debe ser  tan pequeño que pueda ser completamente controlado por nosotros sin temor a  equivocaciones. Es el efecto acumulativo de todas estas modificaciones lo que hace de la  refactorización una potente técnica. El objetivo final de refactorizar es mantener nuestro  código sencillo y bien estructurado.    Las refactorizaciones pueden verse como una forma de mantenimiento preventivo cuyo  objetivo es disminuir la complejidad del software en a"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 1, "text": " es mantener nuestro  código sencillo y bien estructurado.    Las refactorizaciones pueden verse como una forma de mantenimiento preventivo cuyo  objetivo es disminuir la complejidad del software en anticipación a los incrementos de  complejidad que los cambios pudieran traer.    Por tal, ¿por qué es importante la refactorización? cuando se corrige un error o se añade una  nueva función, el valor actual de un programa aumenta. Sin embargo, para que un programa  siga teniendo valor, debe ajustarse a nuevas necesidades (mantenerse), que puede que no  sepamos prever con antelación. La refactorización precisamente facilita la adaptación del  código a nuevas necesidades.    Ventajas    Existen muchas razones por las que deberíamos adoptar esta técnica:    -  Aumenta la calidad: Refactorizar es "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 1, "text": "ción precisamente facilita la adaptación del  código a nuevas necesidades.    Ventajas    Existen muchas razones por las que deberíamos adoptar esta técnica:    -  Aumenta la calidad: Refactorizar es un continuo proceso de reflexión sobre nuestro  código que permite que aprendamos de nuestros desarrollos en un entorno en el que no  hay mucho tiempo para mirar hacia atrás.  Un código de calidad es un código sencillo y bien estructurado, que cualquiera pueda  leer y entender.     -  Desarrollo eficiente: Mantener un buen diseño y un código estructurado es sin duda la  forma más eficiente de desarrollar. El esfuerzo que invirtamos en evitar la duplicación  de código y en simplificar el diseño se verá recompensado cuando tengamos que  realizar modificaciones, tanto para corregir errores como p"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 1, "text": "rrollar. El esfuerzo que invirtamos en evitar la duplicación  de código y en simplificar el diseño se verá recompensado cuando tengamos que  realizar modificaciones, tanto para corregir errores como para añadir nuevas  funcionalidades.    -  Procurar un Diseño Evolutivo en lugar de gran Diseño Inicial: En muchas ocasiones los  requisitos al principio del proyecto no están suficientemente especificados y debemos  abordar el diseño de una forma gradual. Cuando tenemos algunos requisitos claros y no  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 2, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 2 de 45   II/DAS    cambiantes un buen análisis de los mismos puede originar un diseño y una buena  implementación, pero cuando los requisitos van cambiando según avanza el proyecto, y  se añaden nuevas funcionalidades según se le van ocurriendo a los stakeholders, un  diseño inicial no es más que lo que eran los requisitos iniciales, algo generalmente  anticuado. Refactorizar nos permitirá ir evolucionando el diseño según incluyamos  nuevas funcionalidades, lo que implica muchas veces cambios importantes en la  arquitectura, añadir cosas y quitar otras.    -  Facilita la compresión del software: La ref"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 2, "text": " el diseño según incluyamos  nuevas funcionalidades, lo que implica muchas veces cambios importantes en la  arquitectura, añadir cosas y quitar otras.    -  Facilita la compresión del software: La refactorización facilita la comprensión del código  fuente, principalmente para los desarrolladores que no estuvieron involucrados desde el  comienzo del desarrollo. El hecho que el código fuente sea complejo de leer reduce  mucho la productividad ya que se necesita demasiado tiempo para analizarlo y  comprenderlo. Invirtiendo algo de tiempo en refactorizarlo de manera tal que exprese  de forma más clara cuáles son sus funciones, en otras palabras, que sea lo más  autodocumentable posible, facilita su comprensión y mejora la productividad.    -  Ayuda a encontrar errores: Cuando el código fuente "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 2, "text": "lara cuáles son sus funciones, en otras palabras, que sea lo más  autodocumentable posible, facilita su comprensión y mejora la productividad.    -  Ayuda a encontrar errores: Cuando el código fuente es más fácil de comprender  permite detectar condiciones propensas a fallos, o analizar supuestos desde los que se  partió al inicio del desarrollo, que pueden no ser correctos. Mejora la robustez del  código escrito.    -  Evitar la reescritura de código: En la mayoría de los casos refactorizar es mejor que  reescribir. No es fácil enfrentarse a un código que no conocemos y que no sigue los  estándares que uno utiliza, pero eso no es una buena excusa para empezar de cero;  sobre todo en un entorno donde el ahorro de costes y la existencia de sistemas lo  hacen imposible.     -  Ayuda a progra"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 2, "text": "ndares que uno utiliza, pero eso no es una buena excusa para empezar de cero;  sobre todo en un entorno donde el ahorro de costes y la existencia de sistemas lo  hacen imposible.     -  Ayuda a programar más rápidamente: La refactorización permite programar más  rápido, lo que eleva la productividad de los desarrolladores. Un punto importante a la  hora de desarrollar es qué tan rápido se puede hacer, de hecho un factor clave para  permitir el desarrollo rápido es contar con buenos diseños de base.  La velocidad en la programación se obtiene al reducir los tiempos que lleva la aplicación  de cambios, si el código fuente no es fácilmente comprensible, entonces los cambios  llevaran más tiempo. Evita que el diseño comience a perderse. Refactorizar mejora el  diseño, la lectocomprensión del c"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 2, "text": "ambios, si el código fuente no es fácilmente comprensible, entonces los cambios  llevaran más tiempo. Evita que el diseño comience a perderse. Refactorizar mejora el  diseño, la lectocomprensión del código fuente y reduce la cantidad de posibles fallas, lo  que lleva a mejorar la calidad del software entregado, como así también aumenta la  velocidad de desarrollo.    Desventajas    Entre los problemas detectados en el ámbito de la refactorización, podemos destacar:    -  Cambio de las interfaces: Muchas refactorizaciones modifican la interfaz entre  componentes. Lo que no es problema si se tiene acceso a todo el código, ya que se  cambiaría de nombre al servicio y se renombrarían todas las llamadas a ese método. El  problema aparece cuando las interfaces son usadas por código que no se pue"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 2, "text": "ne acceso a todo el código, ya que se  cambiaría de nombre al servicio y se renombrarían todas las llamadas a ese método. El  problema aparece cuando las interfaces son usadas por código que no se puede  encontrar y/o cambiar.    -  Bases de datos: La mayoría de las aplicaciones están fuertemente acopladas al  esquema de la base de datos. Esta es una de las razones por la que la base de datos es  difícil de cambiar. Otra razón es la migración de los datos de una base de datos a otra,  algo bastante costoso.    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 3, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 3 de 45   II/DAS    Qué no es refactorizar    Es importante enfatizar qué no se considerar refactorizar:    -  Refactorizar no es buscar errores, el código ya debe estar en funcionamiento, no  importa si estamos trabajando con un gran programa o solo con un método.  Puede que cuando se esté refactorizando se detecte algún error en el código que  requiere corregirse, es en este momento en que se deja de refactorizar para pasar a  corregir errores.    -  Refactorizar no es mejorar el rendimiento del programa, se puede mejorar el código,  limpiarlo pero esto no implica que el código funcione más rápido.   "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 3, "text": "ctorizar para pasar a  corregir errores.    -  Refactorizar no es mejorar el rendimiento del programa, se puede mejorar el código,  limpiarlo pero esto no implica que el código funcione más rápido.    -  Por tal no se pretende que el código tenga un mayor rendimiento, si no que sea mayor  el rendimiento del programador para que este puede mantener de mejorar manera  dicho código.    -  Refactorizar no es añadir nuevas características, y esto es así porque al refactorizar no  se debe cambiar el comportamiento observable del programa.     Momentos para refactorizar    La refactorización no es una actividad que suele planificarse como parte del proyecto, sino que  ocurre bajo demanda, cuando se necesita. Existe la llamada regla de los tres strikes1 (Fowler)  que sostiene que la tercera vez qu"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 3, "text": "a actividad que suele planificarse como parte del proyecto, sino que  ocurre bajo demanda, cuando se necesita. Existe la llamada regla de los tres strikes1 (Fowler)  que sostiene que la tercera vez que se debe realizar un trabajo similar a uno ya efectuado  deberá refactorizarse. La primera vez se realiza directamente, la segunda vez se realiza la  duplicación y finalmente, a la tercera se refactoriza.    Otros momentos propicios para refactorizar son:    (1) Al momento de agregar funcionalidad: Es común refactorizar al momento de aplicar un  cambio al software ya funcionando, a menudo realizar esto ayuda a comprender mejor  el código sobre el que se está trabajando, principalmente si el código no está  correctamente estructurado.    (2) Al momento de resolver una falla: El reporte de una "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 3, "text": "r esto ayuda a comprender mejor  el código sobre el que se está trabajando, principalmente si el código no está  correctamente estructurado.    (2) Al momento de resolver una falla: El reporte de una falla del software suele indicar que  el código no estaba lo suficientemente claro como para evidenciar la misma.    (3) Al momento de realizar una revisión de código: Entre los beneficios de las revisiones de  código se encuentra la distribución del conocimiento dentro del equipo de desarrollo,  para lo cual la claridad en el código es fundamental. Es común que para el creador del  código este sea claro, pero suele ocurrir que para el resto no lo es.  La refactorización ayuda a que las revisiones de código provean más resultados  concretos, ya que, no solo se realizan nuevas sugerencias sino "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 3, "text": "a claro, pero suele ocurrir que para el resto no lo es.  La refactorización ayuda a que las revisiones de código provean más resultados  concretos, ya que, no solo se realizan nuevas sugerencias sino que se pueden ir  implementando de a poco. Esta idea de revisión de código constante es fuertemente  utilizada con la técnica de pair programming de extreme programming. Esta técnica  involucra dos desarrolladores por computadora. De hecho implica una constante  revisión de código y refactorizaciones a lo largo del desarrollo.    1 En baseball y softball un strike es un buen tiro del pitcher. Luego de tres de ellos el bateador  queda fuera. Una analogía a esto podría ser “la tercera es la vencida”.    Momentos para no refactorizar  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 3, "text": "o de tres de ellos el bateador  queda fuera. Una analogía a esto podría ser “la tercera es la vencida”.    Momentos para no refactorizar  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 4, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 4 de 45   II/DAS      Así como existen momentos que son propicios para las refactorizaciones, existen otros que no  lo son.  Cuando se dispone de código que simplemente no funciona, cuando el esfuerzo necesario para  hacerlo funcionar es demasiado grande por su estructura y la cantidad aparente de fallas que  hacen que sea difícil de estabilizarlo, lo que ocasiona que se deba reescribir el código desde  cero. Una solución factible sería refactorizar el software y dividirlo en varios componentes, y  luego decidir si vale la pena refactorizar o reconstruir componente por componente.    Otro momento para n"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 4, "text": "o. Una solución factible sería refactorizar el software y dividirlo en varios componentes, y  luego decidir si vale la pena refactorizar o reconstruir componente por componente.    Otro momento para no refactorizar es cuando se está próximo a una entrega. En este  momento, la productividad obtenida por la refactorización misma será apreciable solo después  de la fecha de entrega.    Refactorización Continua    Refactorizar de forma continua es una práctica que consiste en mantener el diseño siempre  correcto, refactorizando siempre que sea posible, después de añadir cada nueva funcionalidad.  Esta no es una práctica nueva pero está adquiriendo mayor relevancia de mano de las  metodologías ágiles.    Dado que una refactorización supone un cambio en la estructura del código sin cambiar la  f"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 4, "text": "Esta no es una práctica nueva pero está adquiriendo mayor relevancia de mano de las  metodologías ágiles.    Dado que una refactorización supone un cambio en la estructura del código sin cambiar la  funcionalidad, cuanto mayor sea el cambio en la estructura más difícil será garantizar que no  ha cambiado la funcionalidad. Dicho de otra forma, cuanto mayor sea la refactorización, mayor  es el número de elementos implicados y mayor es el riesgo de que el sistema deje de  funcionar. El tiempo necesario para llevarla a cabo también aumenta y por tanto el coste se  multiplica.    Cuando un diseño no es óptimo y necesita ser refactorizado, cada nueva funcionalidad  contribuye a empeorar el diseño un poco más. Por ello cuanto más tiempo esperamos mayor  es la refactorización necesaria.    Las cla"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 4, "text": "o es óptimo y necesita ser refactorizado, cada nueva funcionalidad  contribuye a empeorar el diseño un poco más. Por ello cuanto más tiempo esperamos mayor  es la refactorización necesaria.    Las claves para poder aplicar refactorización continua son:    -  Concientización de todo el equipo de desarrollo.    -  Habilidad o conocimientos necesarios para identificar qué refactorizaciones son  necesarias.    -  Compartir con todo el equipo de desarrollo la visión de una arquitectura global que guíe  las refactorizaciones en una misma dirección.    El principal riesgo de la refactorización continua consiste en adoptar posturas excesivamente  exigentes o criterios excesivamente personales respecto a la calidad del código. Cuando esto  ocurre se acaba dedicando más tiempo a refactorizar que a d"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 4, "text": "ua consiste en adoptar posturas excesivamente  exigentes o criterios excesivamente personales respecto a la calidad del código. Cuando esto  ocurre se acaba dedicando más tiempo a refactorizar que a desarrollar. La propia presión para  añadir nuevas funcionalidades a la mayor velocidad posible que impone el mercado es  suficiente en ocasiones para prevenir esta situación.    Si se mantiene bajo unos criterios razonables y se realiza de forma continuada la  refactorización debe tender a ocupar una parte pequeña en relación al tiempo dedicado a las  nuevas funcionalidades.    Importancia de las pruebas automáticas    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 4, "text": "pruebas automáticas    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 5, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 5 de 45   II/DAS    Es importante que al momento de aplicar una refactorización primero se ejecuten pruebas  automáticas para determinar que el código funciona. Es decir, que buscamos estar seguros  que el código no tiene errores.   Luego recién refactorizamos para después volver a ejecutar las pruebas correspondientes y  confirmar de esta forma que todo funciona correctamente.    Bad Smells (Malos olores)    Refactorizar es por tanto un medio para mantener el diseño lo más sencillo posible y de  calidad.     Algunas características para lograr un código más simple son:    -  El código funcional (el con"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 5, "text": "   Refactorizar es por tanto un medio para mantener el diseño lo más sencillo posible y de  calidad.     Algunas características para lograr un código más simple son:    -  El código funcional (el conjunto de pruebas de funcionalidad de nuestro código pasa  correctamente).  -  No existe código duplicado.  -  El código permite entender el diseño.  -  Minimiza el número de clases y de métodos.  -  No requiere excesiva cantidad de comentarios para entender el código.    A pesar de todo lo anterior, refactorizar parece ser muchas veces una técnica en contra del  sentido común. ¿Por qué modificar un código que si funciona? ¿Por qué correr el riesgo de  introducir nuevos errores?, ¿Cómo se puede justificar el costo de modificar el código sin  desarrollar ninguna nueva funcionalidad?    Cada refa"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 5, "text": "n código que si funciona? ¿Por qué correr el riesgo de  introducir nuevos errores?, ¿Cómo se puede justificar el costo de modificar el código sin  desarrollar ninguna nueva funcionalidad?    Cada refactorización que realicemos debe estar justificada. Sólo debemos refactorizar cuando  identifiquemos código mal estructurado o diseños que supongan un riesgo para la futura  evolución de nuestro sistema. Si detectamos que nuestro diseño empieza a ser complicado y  difícil de entender, y nos está llevando a una situación donde cada cambio empieza a ser muy  costoso, es en ese momento cuando debemos ser capaces de frenar la inercia de seguir  desarrollando porque si no lo hacemos nuestro software se convertirá en algo inmantenible,  será imposible o demasiado costoso realizar un cambio.    Los sí"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 5, "text": "ser capaces de frenar la inercia de seguir  desarrollando porque si no lo hacemos nuestro software se convertirá en algo inmantenible,  será imposible o demasiado costoso realizar un cambio.    Los síntomas que indican que algún código de software tiene problemas se conocen como “Bad  Smells”. En [Fowler] podemos encontrar una lista de ellos como código duplicado, métodos  largos, clases largas, cláusulas Switch, comentarios, etc.    Una vez identificado el \"Bad Smell\" se debe aplicar una refactorización que permita corregir  ese problema. Para comenzar a refactorizar es imprescindible que el proyecto tenga pruebas  automáticas, tanto unitarias como funcionales, que nos permitan saber en cualquier momento  al ejecutarlas, si el desarrollo sigue cumpliendo los requisitos que implementaba. S"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 5, "text": "proyecto tenga pruebas  automáticas, tanto unitarias como funcionales, que nos permitan saber en cualquier momento  al ejecutarlas, si el desarrollo sigue cumpliendo los requisitos que implementaba. Sin pruebas  automáticas, refactorizar es una actividad que conlleva un alto riesgo. Al término de una  refactorización, sin pruebas automáticas nunca estaremos convencidos de no haber introducido  nuevos errores en el código, y poco a poco dejaremos de hacerlo por miedo a estropear lo que  ya funciona.    A continuación, se describen brevemente los bad smells habituales:    (1) Temporary field (atributo temporal): Ocurre cuando una clase tiene atributos que se  usan solo en algunos métodos específicos y no son esenciales para la clase en general.  Estos atributos pueden hacer que la clase sea "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 5, "text": "ributo temporal): Ocurre cuando una clase tiene atributos que se  usan solo en algunos métodos específicos y no son esenciales para la clase en general.  Estos atributos pueden hacer que la clase sea más difícil de entender y mantener, ya  que no son verdaderamente parte del estado permanente del objeto.    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 6, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 6 de 45   II/DAS    (2) Message chains (cadena de mensajes): Ocurre cuando se tiene múltiples niveles de  invocaciones de métodos a través de objetos, generando una cadena larga de llamadas  como objetoA.getObjetoB().getObjetoC().hacerAlgo(). Este patrón indica un fuerte  acoplamiento entre las clases, lo que puede llevar a un código frágil y difícil de  mantener.    (3) Divergent change (cambio divergente): Ocurre cuando una clase se modifica  frecuentemente por diferentes razones o para diferentes propósitos, violando el  principio de responsabilidad única. Esto significa que la clase tiene demasiadas"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 6, "text": ": Ocurre cuando una clase se modifica  frecuentemente por diferentes razones o para diferentes propósitos, violando el  principio de responsabilidad única. Esto significa que la clase tiene demasiadas  responsabilidades y, como consecuencia, se ve afectada por múltiples tipos de cambios.    (4) Shotgun surgery (cambio en cadena): Ocurre cuando hacer un pequeño cambio en una  clase provoca la necesidad de hacer cambios en muchas otras clases. Esto  generalmente indica que el comportamiento o los datos están dispersos por todo el  sistema, creando un fuerte acoplamiento entre las clases y dificultando el  mantenimiento.  Este problema puede hacer que el código sea difícil de modificar y propenso a errores,  ya que cada pequeño cambio implica realizar modificaciones en varias clases, violando"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 6, "text": "ltando el  mantenimiento.  Este problema puede hacer que el código sea difícil de modificar y propenso a errores,  ya que cada pequeño cambio implica realizar modificaciones en varias clases, violando  el principio de encapsulación y el principio de responsabilidad única.    (5) Data class (clase de datos): Aparece cuando una clase solo tiene atributos y métodos  de acceso (getters y setters) y no tiene ninguna lógica o comportamiento significativo.  Estas clases actúan simplemente como contenedores de datos y, a menudo, son un  síntoma de falta de diseño, ya que no encapsulan adecuadamente el comportamiento  asociado a los datos.  Este tipo de clase puede generar varios problemas:  -  No encapsula bien la lógica, ya que la lógica de negocio puede terminar dispersa en  otras clases que uti"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 6, "text": " comportamiento  asociado a los datos.  Este tipo de clase puede generar varios problemas:  -  No encapsula bien la lógica, ya que la lógica de negocio puede terminar dispersa en  otras clases que utilizan esta clase de datos.  -  Puede haber duplicación de lógica en múltiples lugares.  -  Hace que el sistema sea más difícil de mantener y extender.    (6) Dead code (código muerto): Aparece cuando variables, atributos, métodos o clases ya  no se usan, ya sea porque cambiaron los requerimientos del proyecto o por  correcciones posteriores que hicieron que ya no fueran necesarios. Mantener este tipo  de código es perjudicial, ya que añade ruido innecesario, complica el mantenimiento y  puede confundir a los desarrolladores.    (7) Large class (clase grande): Aparece cuando una clase tiene dem"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 6, "text": "ipo  de código es perjudicial, ya que añade ruido innecesario, complica el mantenimiento y  puede confundir a los desarrolladores.    (7) Large class (clase grande): Aparece cuando una clase tiene demasiados atributos,  métodos y líneas de código, lo que la convierte en una clase que intenta manejar  demasiadas responsabilidades. Esto viola el principio de responsabilidad única  (SRP) y conduce a un código difícil de mantener, propenso a errores y posiblemente  con código duplicado. Este tipo de clase tiende a acumular lógica no relacionada, lo que  puede provocar la aparición de otros bad smells.    (8) Lazy class (clase perezosa): Una \"Lazy Class\" es una clase que no aporta valor  significativo al programa y está subutilizada. Cada clase en un sistema de software  conlleva costos de mant"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 6, "text": "lls.    (8) Lazy class (clase perezosa): Una \"Lazy Class\" es una clase que no aporta valor  significativo al programa y está subutilizada. Cada clase en un sistema de software  conlleva costos de mantenimiento (documentación, pruebas, y esfuerzo para  comprender su propósito).   Si una clase no tiene suficientes responsabilidades o su funcionalidad es tan pequeña  que no justifica su existencia, debe ser eliminada o fusionada con otra clase más  apropiada.    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 7, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 7 de 45   II/DAS    (9) Comments (comentarios): Los comentarios son útiles en el código, pero cuando son  excesivos o innecesarios, pueden indicar que algo está mal en el diseño.   Si un bloque de código necesita comentarios extensos para explicarlo, probablemente el  código no es lo suficientemente claro o no está bien estructurado.   El código bien diseñado debería ser lo suficientemente autoexplicativo, es decir, que su  intención sea clara sin necesidad de añadir comentarios extensivos.    (10)Duplicated code (código duplicado): El código duplicado es uno de los bad smells más  comunes y una de las "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 7, "text": "es decir, que su  intención sea clara sin necesidad de añadir comentarios extensivos.    (10)Duplicated code (código duplicado): El código duplicado es uno de los bad smells más  comunes y una de las principales razones para refactorizar.   Se refiere a situaciones en las que el mismo bloque de código aparece en más de un  lugar dentro de un proyecto, o cuando varias partes del código realizan operaciones  similares, pero no idénticas.   El código duplicado genera problemas de mantenimiento porque cualquier cambio debe  replicarse en todos los lugares donde existe la duplicación.  Tipos de duplicación:  -  Duplicación directa: El mismo código aparece en varios lugares.  -  Duplicación sutil: Fragmentos de código que son diferentes en apariencia, pero en  realidad realizan la misma tarea o "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 7, "text": "licación:  -  Duplicación directa: El mismo código aparece en varios lugares.  -  Duplicación sutil: Fragmentos de código que son diferentes en apariencia, pero en  realidad realizan la misma tarea o tienen la misma lógica subyacente.    (11)Feature envy (envidia de características): Ocurre cuando un método de una clase  accede más frecuentemente a los atributos o métodos de otra clase que a los de su  propia clase.   Este comportamiento indica que el método probablemente esté en la clase incorrecta y  debería ser movido a la clase de la que más depende. Este bad smell viola el principio  de cohesión de las clases y es un síntoma de mal diseño.    (12)Switch statements (estructura de agrupación condicional): Aparece cuando en un  programa se encuentran sentencias switch o múltiples if-else"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 7, "text": "ohesión de las clases y es un síntoma de mal diseño.    (12)Switch statements (estructura de agrupación condicional): Aparece cuando en un  programa se encuentran sentencias switch o múltiples if-else anidados en diferentes  partes del código para manejar decisiones basadas en el tipo de un objeto.   Este tipo de código es propenso a errores porque, cada vez que se agrega una nueva  condición o tipo, es necesario modificar todas las sentencias switch o if-else en todas  las partes donde se encuentran, lo que rompe el principio Abierto/Cerrado (abierto para  la extensión, cerrado para la modificación).    (13)Speculative generality (generalidad especulativa): Ocurre cuando se agregan  funcionalidades al código \"por si acaso\" que podrían ser necesaria en el futuro, pero  que actualmente no t"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 7, "text": "cación).    (13)Speculative generality (generalidad especulativa): Ocurre cuando se agregan  funcionalidades al código \"por si acaso\" que podrían ser necesaria en el futuro, pero  que actualmente no tiene uso.   Este tipo de código introduce complejidad innecesaria, lo que lo hace más difícil de  mantener, entender y probar. Si este comportamiento no se utiliza o es innecesario,  debe eliminarse para mantener el código simple y directo.    (14)Data clumps (grupo de datos): Ocurre cuando ciertos elementos de datos (por ejemplo,  atributos o parámetros) siempre aparecen juntos en varios lugares del código, ya sea  como parámetros en múltiples métodos o como atributos en varias clases.   Esto indica que esos elementos están relacionados entre sí y deberían agruparse en una  clase propia para "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 7, "text": "del código, ya sea  como parámetros en múltiples métodos o como atributos en varias clases.   Esto indica que esos elementos están relacionados entre sí y deberían agruparse en una  clase propia para mejorar la cohesión y facilitar el mantenimiento.    (15)Middleman (intermediario): Ocurre cuando una clase no hace mucho por sí misma y  delega la mayor parte de sus responsabilidades o comportamientos a otra clase. Esto  rompe con el principio de encapsulación, ya que la clase intermediaria no tiene un  propósito claro y simplemente actúa como un puente innecesario.   "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 8, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 8 de 45   II/DAS    Este bad smell puede aparecer como resultado de haber aplicado demasiada delegación  para evitar otros bad smells como “Message Chains” (cadenas de mensajes), pero  termina generando una clase que añade poca o ninguna funcionalidad.    (16)Inappropiate intimacy (intimidad inadecuada): Se presenta cuando una clase accede  directamente a los atributos o métodos privados o protegidos de otra clase, violando el  principio de encapsulación. Esto crea un acoplamiento muy fuerte entre las clases, lo  que dificulta el mantenimiento, reduce la modularidad y aumenta la complejidad.   Idealment"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 8, "text": "a clase, violando el  principio de encapsulación. Esto crea un acoplamiento muy fuerte entre las clases, lo  que dificulta el mantenimiento, reduce la modularidad y aumenta la complejidad.   Idealmente, las clases deberían interactuar a través de interfaces o métodos públicos  claramente definidos, respetando los límites de encapsulación.    (17)Parallel inheritance hierarchies (jerarquías paralelas): Ocurre cuando dos jerarquías de  clases crecen en paralelo. Esto significa que cada vez que se crea una subclase en una  jerarquía, también se debe crear una subclase correspondiente en la otra jerarquía.  Este tipo de diseño causa problemas de duplicación de código y hace que el sistema sea  más difícil de mantener, ya que cualquier cambio o adición en una jerarquía requiere  cambios en la o"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 8, "text": "erarquía.  Este tipo de diseño causa problemas de duplicación de código y hace que el sistema sea  más difícil de mantener, ya que cualquier cambio o adición en una jerarquía requiere  cambios en la otra.    (18)Refused bequest (legado rechazado): Ocurre cuando una subclase hereda métodos o  atributos de una clase base que no necesita o no utiliza. Esto puede suceder porque la  subclase no está completamente alineada con el propósito de la clase base, lo que  conduce a una relación de herencia inadecuada. En estos casos, la subclase \"rechaza\"  parte del comportamiento heredado, lo que indica que quizás la herencia no es la  solución adecuada.  Cuando esto sucede, puede ser mejor refactorizar el código utilizando composición  en lugar de herencia, o crear una jerarquía de clases más apropia"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 8, "text": "ue quizás la herencia no es la  solución adecuada.  Cuando esto sucede, puede ser mejor refactorizar el código utilizando composición  en lugar de herencia, o crear una jerarquía de clases más apropiada.    (19)Long parameter list (lista de parámetros larga): Ocurre cuando un método o  constructor recibe demasiados parámetros. Esto no solo aumenta la complejidad de la  comprensión del código, sino que también incrementa el acoplamiento entre clases, ya  que los métodos que dependen de muchos parámetros son difíciles de mantener y  cambiar.  Idealmente, en programación orientada a objetos, los métodos deben recibir solo los  parámetros necesarios, y se deben utilizar objetos para encapsular conjuntos de datos  relacionados.    (20)Long method (método largo): Ocurre cuando un método tiene de"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 8, "text": "métodos deben recibir solo los  parámetros necesarios, y se deben utilizar objetos para encapsular conjuntos de datos  relacionados.    (20)Long method (método largo): Ocurre cuando un método tiene demasiadas líneas de  código, lo que lo hace difícil de entender, mantener y reutilizar.   Este problema suele ser un legado de la programación estructurada, donde era común  tener métodos o funciones extensos que realizaban múltiples tareas. Sin embargo, en  la programación orientada a objetos, uno de los principios clave es tener métodos  más cortos y específicos, ya que estos son más fáciles de leer, reutilizar y probar.    (21)Primitive obsession (obsesión primitiva): Ocurre cuando se usan excesivamente tipos  primitivos (enteros, cadenas de texto, booleanos, etc.) en lugar de crear objetos "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 8, "text": "eer, reutilizar y probar.    (21)Primitive obsession (obsesión primitiva): Ocurre cuando se usan excesivamente tipos  primitivos (enteros, cadenas de texto, booleanos, etc.) en lugar de crear objetos que  representen conceptos más complejos.   Este bad smell se manifiesta cuando se usan tipos primitivos para representar  entidades que deberían tener un comportamiento específico o cuando se agrupan varios  tipos primitivos relacionados que podrían encapsularse en objetos.  El problema con \"Primitive Obsession\" es que el uso de tipos primitivos tiende a  dispersar la lógica y la validación en el código, en lugar de centralizarla dentro de un  objeto especializado. Esto dificulta la legibilidad, reutilización y mantenimiento del  código.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 8, "text": " código, en lugar de centralizarla dentro de un  objeto especializado. Esto dificulta la legibilidad, reutilización y mantenimiento del  código.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 9, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 9 de 45   II/DAS      (22)Alternative Classes with Different Interfaces (clases alternativas con diferentes  interfaces): Ocurre cuando dos o más clases realizan esencialmente la misma función,  pero exponen métodos con diferentes nombres o firmas (parámetros). Esto genera  inconsistencia en el código, lo que puede dificultar su uso y mantenimiento, ya que los  desarrolladores deben recordar diferentes formas de llamar métodos que hacen lo  mismo.  Este bad smell también puede ocurrir cuando diferentes clases están diseñadas para el  mismo propósito, pero tienen interfaces incompatibles, lo que complica"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 9, "text": "as de llamar métodos que hacen lo  mismo.  Este bad smell también puede ocurrir cuando diferentes clases están diseñadas para el  mismo propósito, pero tienen interfaces incompatibles, lo que complica la integración  de estas clases.    (23)Incomplete Library Class (biblioteca de clases incompleta): Se presenta cuando usamos  una biblioteca de clases de terceros o del propio sistema que no ofrece toda la  funcionalidad que necesitamos, pero no podemos modificar directamente el código de la  biblioteca. Este problema ocurre con frecuencia cuando una clase externa tiene algunas  limitaciones o carece de ciertos métodos o funcionalidades que son esenciales para  nuestro requerimiento.  Dado que las bibliotecas externas suelen ser código cerrado (no se pueden modificar)  o no es recomendable a"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 9, "text": "arece de ciertos métodos o funcionalidades que son esenciales para  nuestro requerimiento.  Dado que las bibliotecas externas suelen ser código cerrado (no se pueden modificar)  o no es recomendable alterarlas (porque podríamos perder compatibilidad o soporte  con futuras versiones), enfrentamos el desafío de extender o adaptar estas clases sin  modificar directamente la biblioteca.    Agrupación de refactorizaciones    La manera de agrupar las refactorizaciones puede ser diversa y no existe un criterio único,  podríamos dividir nuestro análisis y preguntarnos:    -  A nivel de método:   ¿El nombre es correcto?  ¿Los parámetros tienen sentido?  ¿Hay demasiadas variables temporales?  ¿Hay código duplicado?  ¿Sería mejor separar ese código?    -  A nivel de clase:  ¿Ese método debe estar en "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 9, "text": "ombre es correcto?  ¿Los parámetros tienen sentido?  ¿Hay demasiadas variables temporales?  ¿Hay código duplicado?  ¿Sería mejor separar ese código?    -  A nivel de clase:  ¿Ese método debe estar en esta clase?   ¿Hay muchos métodos similares en la clase?    -  A nivel de comunicación entre clases:  ¿La clase A está usando métodos de la clase B?  Si esto se cumple, ¿Por qué es así?    Catálogo de refactorizaciones    En el formato de una refactorización se pueden distinguir cinco partes (Fowler):    (1) Nombre de la refactorización: Importante para construir un vocabulario, de igual forma  que los patrones de diseño han creado un vocabulario las refactorizaciones deben  contribuir a ampliarlo.    (2) Resumen de la que hace y de la situación en la cual se puede necesitar.    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 9, "text": "e los patrones de diseño han creado un vocabulario las refactorizaciones deben  contribuir a ampliarlo.    (2) Resumen de la que hace y de la situación en la cual se puede necesitar.    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 10, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 10 de 45   II/DAS    (3) Motivación: Por qué la refactorización debería aplicarse y las circunstancias en las  cuales no debería usarse.    (4) Mecanismo: Descripción de cómo llevar a cabo la refactorización.    (5) Ejemplo: Un uso de la refactorización.    Por otro lado, hay veces que se utiliza código para describir la refactorización y otros diagramas  UML a nivel de implementación.    A continuación, se presenta la lista de refactorizaciones (Fowler):    Add Parameter: Se aplica cuando un  método no tiene suficientes datos para  realizar determinadas acciones.  Pull Up Constructor Body: Se aplica  c"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 10, "text": " presenta la lista de refactorizaciones (Fowler):    Add Parameter: Se aplica cuando un  método no tiene suficientes datos para  realizar determinadas acciones.  Pull Up Constructor Body: Se aplica  cuando las subclases tienen constructores  con código que en su mayoría es idéntico.  Change Bidirectional Association to  Unidirectional: Se aplica cuando se tiene  una asociación bidireccional entre clases,  pero una de las clases no usa las  características de la otra.  Pull Up Field: Se aplica cuando dos clases  tiene los mismos atributos.  Change Reference to Value: Se aplica  cuando se tiene un objeto de referencia que  es demasiado pequeño y que se cambia con  poca frecuencia para justificar la gestión de  su ciclo de vida.  Pull Up Method: Se aplica cuando las  subclases tienen métodos "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 10, "text": "un objeto de referencia que  es demasiado pequeño y que se cambia con  poca frecuencia para justificar la gestión de  su ciclo de vida.  Pull Up Method: Se aplica cuando las  subclases tienen métodos que realizan un  trabajo similar.  Change Unidirectional Association to  Bidirectional: Se aplica cuando se tiene dos  clases y cada una necesita usar las  características de la otra, pero la asociación  entre ellas es solo unidireccional.  Push Down Field: Se aplica cuando ciertos  atributos de la superclase se usan solo en  pocas subclases.  Change Value to Reference: Se aplica  cuando se tienen muchas instancias idénticas  de una sola clase que necesita reemplazarse  con un solo objeto.  Push Down Method: Se aplica cuando la  lógica del método es aplicable solo a ciertas  subclases.  Collap"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 10, "text": " muchas instancias idénticas  de una sola clase que necesita reemplazarse  con un solo objeto.  Push Down Method: Se aplica cuando la  lógica del método es aplicable solo a ciertas  subclases.  Collapse Hierarchy: Se aplica cuando se  tiene una jerarquía de clases en la que una  subclase es prácticamente igual que su  superclase.  Remove Assignments to Parameters: Se  aplica cuando se asigna algún valor a un  parámetro dentro del cuerpo del método.  Consolidate Conditional Expression: Se  aplica cuando se tienen múltiples condiciones  que conducen al mismo resultado o acción.  Remove Control Flag: Se aplica cuando se  tiene una variable booleana que actúa como  un indicador de control para múltiples  expresiones booleanas, en lugar de utilizar la  sentencia break, continue o return.  Conso"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 10, "text": "lag: Se aplica cuando se  tiene una variable booleana que actúa como  un indicador de control para múltiples  expresiones booleanas, en lugar de utilizar la  sentencia break, continue o return.  Consolidate Duplicate Conditional  Fragments: Se aplica cuando se encuentra  Remove Middleman: Se aplica cuando una  clase tiene demasiados métodos que  simplemente delegan a otros objetos.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 11, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 11 de 45   II/DAS    un código idéntico en todas las ramas de  bloque de condiciones.  Decompose Conditional: Se aplica cuando  se tiene una condición compleja de if/else o  switch.  Remove Parameter: Se aplica cuando un  parámetro no se utiliza en el cuerpo del  método.  Duplicate Observed Data: Se aplica  cuando los datos de dominio se almacenan  en clases responsables de la IGU.   Remove Setting Method: Se aplica cuando  el valor de un atributo se establece solo  cuando se crea y no cambia nunca por lo que  no tiene sentido mantener el método set.  Encapsulate Collection: Se aplica cuando  una clase "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 11, "text": "Se aplica cuando  el valor de un atributo se establece solo  cuando se crea y no cambia nunca por lo que  no tiene sentido mantener el método set.  Encapsulate Collection: Se aplica cuando  una clase contiene un atributo de colección y  los métodos get y set permiten acceder a la  colección completa, en lugar de contar con  los métodos para agregar y eliminar  elementos de la misma.  Rename Method: Se aplica cuando el  nombre del método no explica para qué  sirve.  Encapsulate Downcast: Se aplica cuando  un método devuelve un objeto que necesita  ser casteado por quienes lo invocan, en lugar  de castear dentro de dicho método.  Rename Field: Se aplica cudnao el nombre  del atributo no explica para qué propósito  tiene.  Encapsulate Field: Se aplica cuando los  atributos de una clase son pú"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 11, "text": "de castear dentro de dicho método.  Rename Field: Se aplica cudnao el nombre  del atributo no explica para qué propósito  tiene.  Encapsulate Field: Se aplica cuando los  atributos de una clase son públicos.  Replace Array with Object: Se aplica  cuando un vector contiene distintos datos  que representan al objeto.  Extract Class: Se aplica cuando una clase  hace el trabajo de dos.  Replace Conditional with Polymorphism:  Se aplica cuando una estructura condicional  realiza varias acciones según el tipo de  objeto o propiedades.  Extract Interface: Se aplica cuando varios  clientes utilizan el mismo subconjunto de la  interfaz de una clase o dos clases tienen  parte de sus interfaces en común.  Replace Constructor with Factory  Method: Se aplica cuando se tiene un  constructor complejo que"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 11, "text": " mismo subconjunto de la  interfaz de una clase o dos clases tienen  parte de sus interfaces en común.  Replace Constructor with Factory  Method: Se aplica cuando se tiene un  constructor complejo que hace algo más que  establecer valores de parámetros en  atributos del objeto.  Extract Method: Se aplica cuando se tiene  un fragmento de código que se puede  agrupar.  Replace Data Value with Object: Se  aplica cuando una clase (o grupo de clases)  contiene un atributo que tiene su propio  comportamiento y datos asociados.  Extract Subclass: Se aplica cuando una  clase tiene características que se usan solo  en ciertos casos.  Replace Delegation with Inheritance: Se  aplica cuando una clase contiene muchos  métodos simples, que delegan todo a los  métodos de otra clase.  Extract Superclass: "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 11, "text": "se usan solo  en ciertos casos.  Replace Delegation with Inheritance: Se  aplica cuando una clase contiene muchos  métodos simples, que delegan todo a los  métodos de otra clase.  Extract Superclass: Se aplica cuando se  tienen dos clases con campos y métodos  comunes.  Replace Error Code with Exception: Se  aplica cuando un método devuelve un valor  especial que indica un error.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 12, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 12 de 45   II/DAS    Form Template Method: Se aplica cuando  subclases implementan algoritmos que  contienen pasos similares en el mismo  orden.  Replace Exception with Test: Se aplica  cuando se lanza una excepción marcada en  una condición que podría haberse verificado  previamente por quien invoca.  Hide Delegate: Se aplica cuando el cliente  obtiene el objeto B de un campo o método  del objeto A. Luego, el cliente también llama  a un método del objeto B.  Replace Inheritance with Delegation: Se  aplica cuando se tiene una subclase que usa  solo una parte de los métodos de su  superclase (o no es pos"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 12, "text": " el cliente también llama  a un método del objeto B.  Replace Inheritance with Delegation: Se  aplica cuando se tiene una subclase que usa  solo una parte de los métodos de su  superclase (o no es posible heredar datos de  la superclase).  Hide Method: Se aplica cuando un método  no es usado por otras clases o solo se usa  dentro de su propia jerarquía de clases.  Replace Magic Number with Symbolic  Constant: Se aplica cuando el código usa un  número que tiene cierto significado.  Inline Class: Se aplica cuando una clase no  hace casi nada y no es responsable de nada,  y no se planean responsabilidades  adicionales para ella.  Replace Method with Method Object: Se  aplica cuando se tiene un método largo en el  que las variables locales están tan  entrelazadas que no puede aplicarse la  ref"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 12, "text": "bilidades  adicionales para ella.  Replace Method with Method Object: Se  aplica cuando se tiene un método largo en el  que las variables locales están tan  entrelazadas que no puede aplicarse la  refactorización “Extract method”.  Inline Method: Se aplica cuando la lógica  de un método es tan obvia que no tiene  sentido mantener el método.  Replace Nested Conditional with Guard  Clauses: Se aplica cuando se tiene bloque  de condiciones anidadas y es difícil  determinar el flujo normal de ejecución del  código.  Inline Temp: Se aplica cuando se tiene una  variable temporal a la que se le asigna el  resultado de una expresión simple y nada  más.  Replace Parameter with Explicit  Methods: Se aplica cuando un método se  divide en partes, cada una de las cuales se  ejecuta según el valor de un"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 12, "text": "a el  resultado de una expresión simple y nada  más.  Replace Parameter with Explicit  Methods: Se aplica cuando un método se  divide en partes, cada una de las cuales se  ejecuta según el valor de un parámetro.  Introduce Assertion: Se aplica para que  una parte del código funcione correctamente  asumiendo que ciertas condiciones o valores  deben ser verdaderos.  Replace Parameter with Method: Se  aplica cuando un objeto invoca un método y  luego pasa el resultado como parámetro a  otro método cuando el receptor también  podría invocar este método.  Introduce Explaining Variable: Se aplica  cuando se tiene una expresión complicada.  Replace Record with Data Class: Se  aplica cuando se necesita interactuar con  una estructura de registro en un entorno de  programación tradicional.  Introdu"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 12, "text": "uando se tiene una expresión complicada.  Replace Record with Data Class: Se  aplica cuando se necesita interactuar con  una estructura de registro en un entorno de  programación tradicional.  Introduce Foreign Method: Se aplica  cuando una clase de una biblioteca de clases  no contiene el método que se necesita y no  se tiene la posibilidad de agregarlo. En este  caso, habrá que hacer un método que reciba  como parámetro un objeto del tipo  correspondiente.  Replace Subclass with Fields: Se aplica  cuando se tiene subclases que difieren solo  en sus métodos (de retorno constante).  Introduce Local Extension: Se aplica  cuando una clase de una biblioteca de clases  Replace Temp with Query: Se aplica  cuando se coloca el resultado de una  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 12, "text": "Local Extension: Se aplica  cuando una clase de una biblioteca de clases  Replace Temp with Query: Se aplica  cuando se coloca el resultado de una  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 13, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 13 de 45   II/DAS    no contiene alguno de los métodos que se  necesitan y no puede agregárselos. En este  caso, se deberá heredar de la misma para  poder definirlos.  expresión en una variable local para su uso  posterior en el código.  Introduce Null Object: Se aplica cuando  algunos métodos retornan null en lugar de  objetos reales y se requiere controlar dichos  nulos dentro del código.  Replace Type Code with Class: Se aplica  cuando una clase tiene muchos atributos  númericos para representar distintos tipos y  estos no afectan su comportamiento.  Introduce Parameter Object: Se aplica  cuando los "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 13, "text": "de with Class: Se aplica  cuando una clase tiene muchos atributos  númericos para representar distintos tipos y  estos no afectan su comportamiento.  Introduce Parameter Object: Se aplica  cuando los métodos contienen un grupo  repetido de parámetros.  Replace Type Code with State/Strategy:  Se aplica cuando se tiene un atributo  codificado que afecta el comportamiento,  pero no se puede usar subclases para  deshacerse de él.  Move Field: Se aplica cuando un atributo se  usa más en otra clase que en su propia  clase.  Replace Type Code with Subclasses: Se  aplica cuando se tiene un atributo codificado  que afecta directamente el comportamiento  del programa (los valores de este atributo  activan distintos códigos en los  condicionales).  Move Method: Se aplica cuando un método  se usa más "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 13, "text": "dificado  que afecta directamente el comportamiento  del programa (los valores de este atributo  activan distintos códigos en los  condicionales).  Move Method: Se aplica cuando un método  se usa más en otra clase que en su propia  clase.  Self Encapsulate Field: Se aplica cuando  se utiliza el acceso directo a los atributos  privados dentro de una clase.  Parameterize Method: Se aplica cuando  múltiples métodos realizan acciones similares  que son diferentes solo en sus valores  internos, números u operaciones.  Split Temporary Variable: Se aplica  cuando se tiene una variable local que se usa  para almacenar varios valores intermedios  dentro de un método.  Preserve Whole Object: Se aplica cuando  se obtienen varios valores de un objeto y  luego se pasan como parámetros a un  método, en "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 13, "text": "a  para almacenar varios valores intermedios  dentro de un método.  Preserve Whole Object: Se aplica cuando  se obtienen varios valores de un objeto y  luego se pasan como parámetros a un  método, en lugar de enviar el objeto  completo.  Substitute Algorithm: Se aplica cuando se  quiere reemplazar un algoritmo por otro más  claro.    Bad Smells y sus refactorizaciones más típicas    Bad Smell  Refactorizaciones más utilizadas  Atributo temporal  Extract class. Introduce null object.  Cadena de mensajes  Hide delegate.  Cambio divergente  Extract class.  Cambio en cadena  Move method. Move field. Inline class.  Clase de datos  Move method. Encapsulate field. Encapsulate collection.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 13, "text": "d. Inline class.  Clase de datos  Move method. Encapsulate field. Encapsulate collection.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 14, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 14 de 45   II/DAS    Código muerto  Inline class. Collapse hierarchy. Remove parameter.  Clase grande  Extract class. Extract subclass. Extract interface. Replace data  value with object.  Clase perezosa  Inline class. Collapse hierarchy.  Comentarios  Extract method. Introduce assertion.  Duplicación de código  Extract method. Extract class. Pull up method. Form template  method.  Envidia de  características  Move method. Move field. Extract method.  Estructuras de  agrupación condicional  Replace conditional with polymorphism. Replace type code with  subclasses. Replace type code with state/strategy. "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 14, "text": "as  Move method. Move field. Extract method.  Estructuras de  agrupación condicional  Replace conditional with polymorphism. Replace type code with  subclasses. Replace type code with state/strategy. Replace  parameter with explicit methods. Introduce null object.  Generalidad  especulativa  Collapse hierarchy. Inline class. Remove parameter. Rename  method.  Grupos de datos  Extract class. Introduce parameter object. Preserve whole object.  Intermediario  Remove middleman. Inline method. Replace delegation with  inheritance.  Intimidad inadecuada  Move method. Move field. Change bidirectional association to  unidirectional. Replace inheritance with delegation. Hide delegate.  Jerarquías paralelas  Move method. Move field.  Legado rechazado  Replace inheritance with delegation.  Lista de p"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 14, "text": " association to  unidirectional. Replace inheritance with delegation. Hide delegate.  Jerarquías paralelas  Move method. Move field.  Legado rechazado  Replace inheritance with delegation.  Lista de parámetros  larga  Replace parameter with method. Introduce parameter object.  Preserve whole object.  Método largo  Extract method. Replace temp with query. Replace method with  method object. Decompose conditional.  Obsesión primitiva  Replace data value with object. Extract class. Introduce parameter  object. Replace array with object. Replace type code with class.  Replace type code with subclasses. Replace type code with  state/strategy.  Clases alternativas con  diferentes interfaces  Rename methods. Move method. Add parameter. Parameterize  method. Extract superclass.  Biblioteca de clas"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 14, "text": "sses. Replace type code with  state/strategy.  Clases alternativas con  diferentes interfaces  Rename methods. Move method. Add parameter. Parameterize  method. Extract superclass.  Biblioteca de clases  incompleta  Introduce foreign method. Introduce local extension.    Especificación de algunas refactorizaciones     Refactorización que extrae método  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 15, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 15 de 45   II/DAS      Extract Method: Extraer método  Resumen  Es una operación de refactorización que proporciona una manera sencilla para  crear un nuevo método a partir de un fragmento de código de un miembro  existente.  Motivación  Métodos demasiados largos con partes de código que necesitan un comentario  para entender su propósito.  Mecanismo  (1) Crear un nuevo método con un nombre acorde a su intención.  (2) Copiar el código desde el método fuente hasta el método destino.  (3) Revisar el código buscando variables locales al método. Las variables  son ahora variables locales o parámetros en el "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 15, "text": "nción.  (2) Copiar el código desde el método fuente hasta el método destino.  (3) Revisar el código buscando variables locales al método. Las variables  son ahora variables locales o parámetros en el método destino.  (4) Buscar variables temporales y declararlas en el método destino.  (5) Si alguna variable es modificada, tratar de extraer el código como un  método Query. Asignar a la variable el resultado del método Query.  (6) Los parámetros son aquellas variables que necesitan ser leídas a partir  del código extraído.  (7) Reemplazar el código extraído con la invocación al nuevo método.  (8) Compilar y probar.  Ejemplo  public void printInvoice(Order order) {  //Imprimir el encabezado de la factura  System.out.println (\"Factura\");  System.out.println (\"=================================\""}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 15, "text": ") Compilar y probar.  Ejemplo  public void printInvoice(Order order) {  //Imprimir el encabezado de la factura  System.out.println (\"Factura\");  System.out.println (\"=================================\");    //Imprimir datos del cliente  System.out.println (\"Cliente \");  System.out.println (order.getCustomer().getName());    //...  }        public void printInvoice(Order order) {  printInvoiceHeader();    //Imprimir datos del cliente  System.out.println (\"Cliente \");  System.out.println (order.getCustomer().getName());    //...  }    public void printInvoiceHeader() {  System.out.println (\"Factura\");  System.out.println (\"=================================\");  }          public void printInvoice(Order order) {  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 15, "text": "ra\");  System.out.println (\"=================================\");  }          public void printInvoice(Order order) {  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 16, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 16 de 45   II/DAS    printInvoiceHeader();    printCustomerDetails(order.getCustomer());    //...  }    public void printInvoiceHeader() {  System.out.println (\"Factura\");  System.out.println (\"=================================\");  }    public void printCustomerDetails(Customer customer) {  System.out.println (\"Cliente \");  System.out.println (customer.getName());  }      Método de refactorización en línea    Inline Method: Método en línea  Resumen  El cuerpo de un método es tan claro como su nombre.  Motivación  Mucha delegación.  Mecanismo  (1) Chequear que el método no es polimórfico.  (2) Encontrar "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 16, "text": "   Inline Method: Método en línea  Resumen  El cuerpo de un método es tan claro como su nombre.  Motivación  Mucha delegación.  Mecanismo  (1) Chequear que el método no es polimórfico.  (2) Encontrar todas las llamadas al método.  (3) Reemplazar cada llamada con el cuerpo del método.  (4) Compilar y probar.  (5) Remover la definición del método.  Ejemplo  public void calculateAreaOfCircle(double radius) {  double area = getValueOfPI() * Math.pow(radius, 2);  System.out.println (\"Area: \" + area);  }    private double getValueOfPI () {  return Math.PI;  }          public void calculateAreaOfCircle(double radius) {  double area = Math.PI * Math.pow(radius, 2);  System.out.println (\"Area: \" + area);  }    Refactorizaciones que eliminan temporales    Replace Temp with Query: Reemplazar temporal"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 16, "text": "le(double radius) {  double area = Math.PI * Math.pow(radius, 2);  System.out.println (\"Area: \" + area);  }    Refactorizaciones que eliminan temporales    Replace Temp with Query: Reemplazar temporales con consultas  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 17, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 17 de 45   II/DAS    Resumen  Extraer la expresión en un método. Sustituir todas las referencias de la variable  por la invocación al método. El nuevo método puede ser luego utilizado en  otros métodos.  Motivación  Se está utilizando una variable temporal para manejar el resultado de una  expresión.  Mecanismo  (1) Buscar la variable temporal que es asignada una sola vez.  (2) Declarar la variable como final.  (3) Compilar  (4) Extraer la expresión del lado derecho como un nuevo método.  (5) Compilar y probar  (6) Reemplazar la variable temporal por el método extraído.  Ejemplo  public boolean checkWit"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 17, "text": "al.  (3) Compilar  (4) Extraer la expresión del lado derecho como un nuevo método.  (5) Compilar y probar  (6) Reemplazar la variable temporal por el método extraído.  Ejemplo  public boolean checkWithdrawalStatus(double amoutToWithdraw) {      //Crear temporal      double availableBalance = _balance - _pendingCharges;        //Usa temporal      if(availableBalance > amoutToWithdraw) {          System.out.println(\"Aceptado\");          return true;      }      else {          System.out.println(\"Solo tienes \" + availableBalance + \"  disponible\");          return false;      }  }          public boolean checkWithdrawalStatus(double amoutToWithdraw) {      if(getAvailableBalance() > amoutToWithdraw) {          System.out.println(\"Aceptado\");          return true;      }      else {          S"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 17, "text": " boolean checkWithdrawalStatus(double amoutToWithdraw) {      if(getAvailableBalance() > amoutToWithdraw) {          System.out.println(\"Aceptado\");          return true;      }      else {          System.out.println(\"Solo tienes \" + getAvailableBalance() +  \" disponible\");          return false;      }  }       private double getAvailableBalance() {      return _balance - _pendingCharges;  }      Inline Temp: Temporales en línea  Resumen  Quitar variable temporal utilizar una única vez.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 18, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 18 de 45   II/DAS    Motivación  Variable temporal involucrada en la refactorización y es asignada solo una vez.  Mecanismo  (1) Declarar la variable temporal como final si aún no lo está (verifica que  está asignada una sola vez).  (2) Encontrar todas las referencias a la variable temporal y reemplazarla  con el lado derecho de la expresión.  (3) Compilar y probar.  (4) Remover la declaración y asignación a la variable.  (5) Compilar y probar.  Ejemplo  public boolean checkWithdrawalStatus(double amoutToWithdraw) {      final double temp = getAvailableBalance();            if(temp > amoutToWithdraw) { "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 18, "text": "a la variable.  (5) Compilar y probar.  Ejemplo  public boolean checkWithdrawalStatus(double amoutToWithdraw) {      final double temp = getAvailableBalance();            if(temp > amoutToWithdraw) {          System.out.println(\"Aceptado\");          return true;      }      else {          System.out.println(\"Solo tienes \" + temp + \" disponible\");          return false;      }  }       private double getAvailableBalance() {      return _balance - _pendingCharges;  }              public boolean checkWithdrawalStatus(double amoutToWithdraw) {      if(getAvailableBalance() > amoutToWithdraw) {          System.out.println(\"Aceptado\");          return true;      }      else {          System.out.println(\"Solo tienes \" + getAvailableBalance() +  \" disponible\");          return false;      }  }  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 18, "text": "       System.out.println(\"Aceptado\");          return true;      }      else {          System.out.println(\"Solo tienes \" + getAvailableBalance() +  \" disponible\");          return false;      }  }       private double getAvailableBalance() {      return _balance - _pendingCharges;  }    Refactorizaciones que añaden temporales    Split Temporary Variable: División de variables temporales  Resumen  Hacer una variable temporal por cada asignación.  Motivación  Variable temporal asignada más de una vez.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 19, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 19 de 45   II/DAS    Mecanismo  (1) Cambiar el nombre de la variable temporal y su primera asignación.  (2) Declarar la nueva variable temporal como final.  (3) Cambiar todas las referencias de la variable temporal antes de su  segunda asignación.  (4) Declarar la variable temporal en la segunda asignación.  (5) Compilar y probar.  (6) Repetir en etapas, en cada etapa renombrar la variable y cambiar las  referencias hasta la próxima asignación.  Ejemplo  double temp = item.getPrice() * item.getQuantity();  System.out.println(\"Total por línea: \" + temp);    temp = order.getTotal() - order.getDiscount(); "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 19, "text": "ferencias hasta la próxima asignación.  Ejemplo  double temp = item.getPrice() * item.getQuantity();  System.out.println(\"Total por línea: \" + temp);    temp = order.getTotal() - order.getDiscount();  System.out.println(\"Cantidad debida: \" + temp);          double lineTotal = item.getPrice() * item.getQuantity();  System.out.println(\"Total por línea: \" + lineTotal);    double amountDue = order.getTotal() - order.getDiscount();  System.out.println(\"Cantidad debida: \" + amountDue);      Introduce Explaining Variable: Introducir variables explicativas  Resumen  Hacer el código más entendible.  Motivación  Expresiones complicadas.  Mecanismo  (1) Declarar la variable temporal como final, y asignarle el resultado  asociado a la parte de la expresión compleja.  (2) Reemplazar la parte de la expr"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 19, "text": "tivación  Expresiones complicadas.  Mecanismo  (1) Declarar la variable temporal como final, y asignarle el resultado  asociado a la parte de la expresión compleja.  (2) Reemplazar la parte de la expresión con la variable temporal.  (3) Compilar y probar.  (4) Repetir pasos 1 al 3 para el resto de la expresión.  Ejemplo  if(stock.checkStatus(order.getItem()) > order.getQuantity() &&      order.getTotal() > 99 &&      order.getCustomer().getBillingAddress().getLinel().  equals(order.getShippingAddress().getLinel())) {      System.out.println(\"Aceptado\");      ...  }  else {      ...  }          final boolean stockAvailable = stock.checkStatus(order.getItem()) >  order.getQuantity();    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 19, "text": " final boolean stockAvailable = stock.checkStatus(order.getItem()) >  order.getQuantity();    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 20, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 20 de 45   II/DAS    final boolean freeShipping = order.getTotal() > 99;    final boolean addressMatches =  order.getCustomer().getBillingAddress().  getLinel().equals(order.getShippingAddress().getLinel());    if(stockAvailable && freeShipping && addressMatches) {      System.out.println(\"Aceptado\");      // ...  }  else {      // ...  }      Remove Assignments to Parameters: Eliminar asignaciones a parámetros  Resumen  El parámetro es reasignado dentro del método.  Motivación  Evitar la modificación del parámetro recibido.  Mecanismo  (1) Crear una variable temporal para el parámetro.  (2) Reemplazar "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 20, "text": "tros  Resumen  El parámetro es reasignado dentro del método.  Motivación  Evitar la modificación del parámetro recibido.  Mecanismo  (1) Crear una variable temporal para el parámetro.  (2) Reemplazar todas las referencias hechas al parámetro después de la  asignación, a la variable temporal.  (3) Cambiar la asignación del parámetro a la asignación de la variable  temporal.  (4) Compilar y probar.  Ejemplo  public void checkStock(OrderItem item, int desired) {      //¿Se puede cumplir con el pedido?      if(item.getStockUnits() < desired) {          //Asignando a un parámetro primitivo          desired = item.getStockUnits();          System.out.println(\"Solo \" + desired + \" unidades  disponibles\");                    //Asignando a un parámetro de objeto          item = new OrderItem(item.g"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 20, "text": " desired = item.getStockUnits();          System.out.println(\"Solo \" + desired + \" unidades  disponibles\");                    //Asignando a un parámetro de objeto          item = new OrderItem(item.getAlternateID());          System.out.println(\"Sugiero \" + item.getName() + \" en su  lugar\");                    // ...      }      // ...  }              public void checkStock(OrderItem item, int desired) {      //¿Se puede cumplir con el pedido?      if(item.getStockUnits() < desired) {          //Se usa una temporal en línea en lugar de asignar al  parámetro  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 21, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 21 de 45   II/DAS            System.out.println(\"Solo \" + item.getStockUnits() + \"  unidades disponibles\");                    //Se usa una nueva temporal en lugar de asignar al  parámetro          OrderItem alternate = new OrderItem(item.getAlternateID());           System.out.println(\"Sugiero \" + alternate.getName() + \" en  su lugar\");                    // ...      }      // ...  }        Refactorización que reemplaza método con método de un objeto    Replace Method with Method Object: Reemplazar método con método de un objeto  Resumen  Método largo que usa variables locales y no se puede usar “Extra"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 21, "text": " que reemplaza método con método de un objeto    Replace Method with Method Object: Reemplazar método con método de un objeto  Resumen  Método largo que usa variables locales y no se puede usar “Extract Method”  Motivación  Crear métodos más sencillos para hacer más compresible el código.  Mecanismo  (1) Crear una nueva clase cuyo nombre es el método.  (2) Agregar a la nueva clase un campo del tipo final hacia el objeto origen y  un campo para cada variable temporal y cada parámetro en el método.  (3) Crear un constructor que recibe el objeto fuente y cada parámetro.  (4) Crear un nuevo método “compute” en la nueva clase.  (5) Copiar el cuerpo del método original en el método “compute”. Usar el  campo del objeto fuente para cualquier invocación a los métodos del  objeto original.  (6) Comp"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 21, "text": " “compute” en la nueva clase.  (5) Copiar el cuerpo del método original en el método “compute”. Usar el  campo del objeto fuente para cualquier invocación a los métodos del  objeto original.  (6) Compilar.  (7) Reemplazar el método viejo por uno que crea el objeto nuevo e invoque  el método “compute”.  Ejemplo  class Order {      public double price() {      double primaryBasePrice;      double secondaryBasePrice;      double tertiaryBasePrice;        // long computation;      }    }          "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 22, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 22 de 45   II/DAS      Refactorización que sustituye algoritmo    Substitute Algorithm: Sustituir algoritmo  Resumen  Reemplazar un algoritmo por uno más claro.  Motivación  Crear métodos más sencillos para hacer más compresible el código.  Mecanismo  (1) Preparar algoritmo alternativo tal que compile.  (2) Ejecutar y probar el nuevo algoritmo.  (3) Si los resultados no son los mismos, usar el viejo algoritmo para  comparar al probar.  Ejemplo  public String foundPerson(String[] people){    for (int i = 0; i < people.length; i++) {      if (people[i].equals (\"Don\")){        return \"Don\";      }      if "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 22, "text": "mo para  comparar al probar.  Ejemplo  public String foundPerson(String[] people){    for (int i = 0; i < people.length; i++) {      if (people[i].equals (\"Don\")){        return \"Don\";      }      if (people[i].equals (\"John\")){        return \"John\";      }      if (people[i].equals (\"Kent\")){        return \"Kent\";      }    }    return \"\";  }          public String foundPerson(String[] people){    List candidates = Arrays.asList(new String[] {\"Don\", \"John\",  \"Kent\"});    for (int i=0; i<people.length; i++)  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 23, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 23 de 45   II/DAS        if (candidates.contains(people[i]))        return people[i];      return \"\";    }  }    Refactorización que mueve métodos    Move Method: Mover método  Resumen  Crear un nuevo método con un cuerpo similar en la clase que cuenta con la  mayoría de las características utilizadas. Cambiar el viejo método con una  simple delegación, o eliminarlo por completo.  Motivación  Un método que utiliza más características de otra clase que de la clase en la  que está definido.   Mecanismo  (1) Examinar todas las características utilizadas por el método fuente que se  definen en la clase orig"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 23, "text": "utiliza más características de otra clase que de la clase en la  que está definido.   Mecanismo  (1) Examinar todas las características utilizadas por el método fuente que se  definen en la clase origen.  (2) Comprobar las subclases y superclases.  (3) Declarar el método en la clase destino.  (4) Copiar el código del método a la clase destino. Ajustar el método para  que funcione en la nueva clase.  (5) Compilar la clase destino.  (6) Reemplazar las llamadas originales.  (7) Compilar y probar.  Ejemplo  public class Customer {        private String name;        ...            public void printInvoice(Order order) {          //Imprimir encabezado de la factura          System.out.println(\"Invoice: \" + order.getOrderID());          System.out.println(\"Date: \" + order.getDate().toString());  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 23, "text": "Invoice(Order order) {          //Imprimir encabezado de la factura          System.out.println(\"Invoice: \" + order.getOrderID());          System.out.println(\"Date: \" + order.getDate().toString());                    //Imprimir datos del cliente          System.out.println(\"Customer: \");          System.out.println(this.getName());            Address address = order.getAddress();          System.out.println(\" \" + address.getStreet());          System.out.println(\" \" + address.getCity());          System.out.println(\" \" + address.getState());          System.out.println(\" \" + address.getZip());                    System.out.println(\"Order Items:\");          Item[] items = order.getItems();          for(int i = 0; i < items.length; i ++) {              System.out.println(\"* Name: \" + items["}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 23, "text": ";                    System.out.println(\"Order Items:\");          Item[] items = order.getItems();          for(int i = 0; i < items.length; i ++) {              System.out.println(\"* Name: \" + items[i].getName());              System.out.println(\"* ID: \" + items[i].getId());  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 24, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 24 de 45   II/DAS                System.out.println(\"* Quantity: \" +  items[i].getQuantity());              System.out.println(\"* Price: \" + items[i].getPrice());          }      }            ...        }        public class Order {        private int orderID;      private Date date;      private Customer customer;      private Address address;      private Item[] items;            ...            public void printInvoice() {          //Imprimir encabezado de la factura          System.out.println(\"Invoice: \" + this.getOrderID());          System.out.println(\"Date: \" + this.getDate().toString());        "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 24, "text": "d printInvoice() {          //Imprimir encabezado de la factura          System.out.println(\"Invoice: \" + this.getOrderID());          System.out.println(\"Date: \" + this.getDate().toString());                    //Imprimir datos del cliente          System.out.println(\"Customer: \");          System.out.println(this.getCustomer().getName());            Address address = this.getAddress();          System.out.println(\" \" + address.getStreet());          System.out.println(\" \" + address.getCity());          System.out.println(\" \" + address.getState());          System.out.println(\" \" + address.getZip());                    System.out.println(\"Order Items:\");          Item[] items = this.getItems();          for(int i = 0; i < items.length; i ++) {              System.out.println(\"* Name: \" + "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 24, "text": "tZip());                    System.out.println(\"Order Items:\");          Item[] items = this.getItems();          for(int i = 0; i < items.length; i ++) {              System.out.println(\"* Name: \" + items[i].getName());              System.out.println(\"* ID: \" + items[i].getId());              System.out.println(\"* Quantity: \" +  items[i].getQuantity());              System.out.println(\"* Price: \" + items[i].getPrice());          }      }            ...        }    Refactorización que extrae clases    Extract class: Extraer clase  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 25, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 25 de 45   II/DAS    Resumen  Crear una nueva clase y mover los campos y métodos pertenecientes a la vieja  clase en la nueva clase.  Motivación  La clase realiza más cosas que lo que originalmente iba hacer.  Mecanismo  (1) Decidir cómo dividir las responsabilidades de la clase.  (2) Crear una nueva clase para expresar las responsabilidades a extraer.  (3) Hacer un vínculo desde la antigua a la nueva clase.  (4) Utilizar “Mover campo” en cada campo que se desea mover.  (5) Compilar y probar después de cada movimiento.  (6) Utilizar “Mover método” para mover métodos de la clase viaja a la  nueva.   (7) "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 25, "text": ".  (4) Utilizar “Mover campo” en cada campo que se desea mover.  (5) Compilar y probar después de cada movimiento.  (6) Utilizar “Mover método” para mover métodos de la clase viaja a la  nueva.   (7) Compilar y probar después de cada movimiento.  (8) Revisar y reducir las interfaces de cada clase.  (9) Decidir si se va a exponer la nueva clase.   Ejemplo  class Customer {        private String name;      private String officeAreaCode;      private String officeNumber;        public String getName() {          return this.name;      }        public void setName(String arg) {          this.name = arg;      }            public String getTelephoneNumber() {          return (\"(\" + this.officeAreaCode + \") \" +  this.officeNumber);      }            public String getOfficeAreaCode() {          re"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 25, "text": "= arg;      }            public String getTelephoneNumber() {          return (\"(\" + this.officeAreaCode + \") \" +  this.officeNumber);      }            public String getOfficeAreaCode() {          return this.officeAreaCode;      }            public void setOfficeAreaCode(String arg) {          this.officeAreaCode = arg;      }            public String getOfficeNumber() {          return this.officeNumber;      }            public void setOfficeNumber(String arg) {          this.officeNumber = arg;      }    }            "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 26, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 26 de 45   II/DAS    public class TelephoneNumber {        private String officeAreaCode;      private String officeNumber;            public String getTelephoneNumber() {          return (\"(\" + this.officeAreaCode + \") \" +  this.officeNumber);      }            public String getOfficeAreaCode() {          return this.officeAreaCode;      }            public void setOfficeAreaCode(String arg) {          this.officeAreaCode = arg;      }            public String getOfficeNumber() {          return this.officeNumber;      }            public void setOfficeNumber(String arg) {          this.officeNumber = "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 26, "text": "s.officeAreaCode = arg;      }            public String getOfficeNumber() {          return this.officeNumber;      }            public void setOfficeNumber(String arg) {          this.officeNumber = arg;      }    }    class Customer {        private String name;      private TelephoneNumber officeTelephone;                public String getName() {          return this.name;      }        public void setName(String arg) {          this.name = arg;      }        public String getTelephoneNumber(){          return this.officeTelephone.getTelephoneNumber();      }            public TelephoneNumber getOfficeTelephone() {          return this.officeTelephone;      }            public void setOfficeTelephone(TelephoneNumber arg) {          this.officeTelephone = arg;      }        }      "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 26, "text": "er getOfficeTelephone() {          return this.officeTelephone;      }            public void setOfficeTelephone(TelephoneNumber arg) {          this.officeTelephone = arg;      }        }      "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 27, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 27 de 45   II/DAS    Nota  La refactorización que realiza el proceso inverso se conoce como Inline Class:  Clase en línea, es decir, una clase que no tiene demasiados atributos y sus  métodos son simples y no agrega demasiado valor, termina siendo absorbida  por otra clase.  Esto se presenta mucho cuando se mueven métodos entre clases y dejan  alguna de ellas sin demasiado que aportar, por tal se terminan de migrar su  definición y se borra dicha clase.     Haciendo condicionales más fáciles de leer    Decompose Conditional: Descomposición condicional  Resumen  Extraer la expresión condicional y crear u"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 27, "text": "e migrar su  definición y se borra dicha clase.     Haciendo condicionales más fáciles de leer    Decompose Conditional: Descomposición condicional  Resumen  Extraer la expresión condicional y crear un método que luego se utilice en la  sentencia condicional.  Motivación  Se tiene una expresión condicional complicada.  Mecanismo  (1) Extraer la condición creando un nuevo método que retorne el resultado  de la misma.  (2) Modificar la sentencia condicional utilizando el método creado.  (3) Compilar y probar.  Ejemplo  if(order.getCustomer().getStatus().equals(\"P\") ||   (order.getTotal() > 1000 && order.getWeight() < 500)) {    shipping = order.getTotal() * 0.05;    if(shipping > 100) shipping = 100;  }  else {    shipping = order.getTotal() * 0.08;    if(shipping > 200) shipping = 200;  }  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 27, "text": "&& order.getWeight() < 500)) {    shipping = order.getTotal() * 0.05;    if(shipping > 100) shipping = 100;  }  else {    shipping = order.getTotal() * 0.08;    if(shipping > 200) shipping = 200;  }          if(largeOrImportant(order)) {    shipping = discountShippingRate(order);  }  else {    shipping = normalShippingRate(order);  }    public boolean largeOrImportant(Order order) {    return order.getCustomer().getStatus().equals(\"P\") ||  (order.getTotal() > 1000 && order.getWeight() < 500);  }    public double discountShippingRate(Order order) {    double result = order.getTotal() * 0.05;    if(result > 100) result = 100;    return result;  }    public double normalShippingRate(Order order) {  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 27, "text": " if(result > 100) result = 100;    return result;  }    public double normalShippingRate(Order order) {  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 28, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 28 de 45   II/DAS      double result = order.getTotal() * 0.08;    if(result > 200) result = 200;    return result;  }      Consolidate Conditional Expression: Consolidar la expresión condicional  Resumen  Se combina en una única expresión condicional el conjunto de expresiones que  tienen el mismo resultado.  Motivación  Se tiene un conjunto de condiciones con el mismo resultado.  Mecanismo  (1) Comprobar que ninguna de las expresiones condiciones tiene un efecto  secundario.  (2) Armar una única expresión condicional utilizando operadores lógicos.  (3) Compilar y probar.  (4) Considerar el uso de “Ext"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 28, "text": "que ninguna de las expresiones condiciones tiene un efecto  secundario.  (2) Armar una única expresión condicional utilizando operadores lógicos.  (3) Compilar y probar.  (4) Considerar el uso de “Extraer método” para la condición construida.  Ejemplo  public double calculateShipping() {    if(_isEmployee) return 0;    if(_isPlatinumCustomer) return 0;    if(_isGoldCustomer) return 0;    if(_hasCoupon) return 0;      //Calcular el envío    //...  }          public double calculateShipping() {    if(freeShipping()) return 0;       //Calcular el envío     //...  }    public boolean freeShipping() {     return (_isEmployee || _isPlatinumCustomer || _isGoldCustomer  || _hasCoupon);  }      Consolidate Duplicate Conditional Fragments: Consolidación de fragmentos de código  condicional duplicado"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 28, "text": ") {     return (_isEmployee || _isPlatinumCustomer || _isGoldCustomer  || _hasCoupon);  }      Consolidate Duplicate Conditional Fragments: Consolidación de fragmentos de código  condicional duplicados  Resumen  Aquel fragmento de código que se repite se mueve fuera de la expresión.  Motivación  El mismo fragmento de código se encuentra en todas las ramas de la sentencia  condicional.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 29, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 29 de 45   II/DAS    Mecanismo  (1) Identificar el código que se ejecuta de la misma manera  independientemente de la condición.  (2) Si el código común es al principio, moverlo antes del condicional.  (3) Si el código común es al final, moverlo después del condicional.  (4) Si el código común está en el medio, evaluar si el código anterior o  posterior no cambia nada. Si lo hace, puede mover el código común  hacia adelante o hacia atrás a los extremos y a continuación, se puede  mover como se describe para el código al final o al principio.  (5) Si hay más de una declaración, se debe extraer ese código"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 29, "text": "n  hacia adelante o hacia atrás a los extremos y a continuación, se puede  mover como se describe para el código al final o al principio.  (5) Si hay más de una declaración, se debe extraer ese código en un  método.  Ejemplo  if(largeOrImportant(order)) {    shipping = discountShippingRate(order);    order.addShippingCost(shipping);  }  else {    shipping = normalShippingRate(order);    order.addShippingCost(shipping);  }          if(largeOrImportant(order)) {    shipping = discountShippingRate(order);  }  else {    shipping = normalShippingRate(order);  }  order.addShippingCost(shipping);    Refactorización que reemplaza condicional con polimorfismo    Replace Conditional with Polymorphism: Reemplazar condicional con polimorfismo  Resumen  El método que contiene la sentencia condicional s"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 29, "text": "Refactorización que reemplaza condicional con polimorfismo    Replace Conditional with Polymorphism: Reemplazar condicional con polimorfismo  Resumen  El método que contiene la sentencia condicional se sobrescribe en las subclases  y se convierte el  método de la superclase en abstracto.  Motivación  Se cuenta con una sentencia condicional que elige un comportamiento diferente  en función de un tipo de objeto.  Mecanismo  (1) Si la sentencia condicional es una parte de un método más grande,  desarmar la sentencia condicional y utilizar “Extraer método”.  (2) Si es necesario, utilizar “Mover método” para colocar el condicional en la  superclase.  (3) Tomar una de las subclases, crear un método que anule la sentencia  condicional. Copiar el cuerpo de la instrucción condicional en el método  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 29, "text": "todo” para colocar el condicional en la  superclase.  (3) Tomar una de las subclases, crear un método que anule la sentencia  condicional. Copiar el cuerpo de la instrucción condicional en el método  de la subclase y ajustarlo a su medida.  (4) Compilar y probar.  (5) Eliminar esa parte de la sentencia condicional.  (6) Compilar y probar.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 30, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 30 de 45   II/DAS    (7) Repetir el procedimiento con cada parte de la sentencia condicional  hasta que todas las condiciones evaluadas se conviertan en métodos de  subclases.  (8) Hacer que el método se convierta en abstracto en la superclase.  Ejemplo  public double getSpeed() {    switch (_type) {          case EUROPEAN:            return getBaseSpeed();          case AFRICAN:            return getBaseSpeed() - getLoadFactor() *  _numberOfCoconuts;          case NORWEGIAN_BLUE:            return (_isNailed) ? 0 : getBaseSpeed(_voltage);      }      throw new RuntimeException (\"Should be unreachable\")"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 30, "text": "eed() - getLoadFactor() *  _numberOfCoconuts;          case NORWEGIAN_BLUE:            return (_isNailed) ? 0 : getBaseSpeed(_voltage);      }      throw new RuntimeException (\"Should be unreachable\");  }          Refactorización que reemplaza código de tipo con subclases    Replace Type Code with Subclasses: Reemplazar código de tipo con subclases  Resumen  Se reemplaza la tipificación de código con subclases.  Motivación  Según el tipo del objeto, se determina el comportamiento de la clase.  Mecanismo  (1) Encapsular la tipificación del código.  (2) Por cada valor de tipificación, crear una subclase. Sobrescribir el método  de obtención del objeto (get) en cada subclase con el retorno que  corresponda.  (3) Quitar de la superclase el campo que representa cada tipificación.  Declarar el m"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 30, "text": "subclase. Sobrescribir el método  de obtención del objeto (get) en cada subclase con el retorno que  corresponda.  (3) Quitar de la superclase el campo que representa cada tipificación.  Declarar el método de obtención del objeto como abstracto.  (4) Compilar y probar.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 31, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 31 de 45   II/DAS    Ejemplo            Refactorizaciones de encapsulamiento    Self Encapsulate Field: Auto encapsulamiento de campo  Resumen  Crear los métodos accesores del campo y utilizarlos para acceder al mismo.  Motivación  Se está utilizando el campo directamente pero el acoplamiento con el campo  resulta engorroso.  Mecanismo  (1) Crear los métodos accesores del campo.  (2) Encontrar todas las referencias al campo y reemplazarlas con el método  accesor que corresponda.  (3) Hacer el campo privado.  (4) Verificar que todas las referencias están corregidas.  (5) Compilar y probar.  Ejemplo  clas"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 31, "text": "erencias al campo y reemplazarlas con el método  accesor que corresponda.  (3) Hacer el campo privado.  (4) Verificar que todas las referencias están corregidas.  (5) Compilar y probar.  Ejemplo  class IntRange {      private int _low, _high;      public boolean includes (int arg) {      return arg >= this._low && arg <= this._high;    }      //...  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 32, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 32 de 45   II/DAS    }          class IntRange {    private int _low, _high;      public int getLow() {      return this._low;    }      public int getHigh() {      return this._high;    }      public boolean includes (int arg) {      return arg >= this.getLow() && arg <= this.getHigh();    }      //...  }      Encapsulate Field: Encapsulamiento de campos  Resumen  Hacer privado el acceso al campo y programar los métodos accesores.  Motivación  Hay campos con acceso público.  Mecanismo  (1) Crear los métodos accesores del campo.  (2) Encontrar las llamadas fuera de la clase que hacen referencia al campo"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 32, "text": "ar los métodos accesores.  Motivación  Hay campos con acceso público.  Mecanismo  (1) Crear los métodos accesores del campo.  (2) Encontrar las llamadas fuera de la clase que hacen referencia al campo.  Reemplazar las mismas con el método accesor que corresponda.  (3) Compilar y probar después de cada cambio.  (4) Una vez que todas las referencias se cambiaron, declarar el campo como  privado.  (5) Compilar y probar.  Ejemplo  class Person {        public String _name;            //...  }          class Person {      private String _name;      public String getName() {      return this._name;  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 32, "text": " "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 33, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 33 de 45   II/DAS      }      public void setName(String arg) {      this._name = arg;    }      //...  }    Refactorización que mueve campos    Move Field: Mover campos  Resumen  Se crea un nuevo campo en la clase destino y se actualiza la referencia al  mismo.  Motivación  Un campo es o será utilizado por otra/s clases más que la clase donde fue  definido.  Mecanismo  (1) Si el campo es público, utilizar “Encapsulamiento de campo”.  (2) Compilar y probar.  (3) Crear un campo en la clase destino con los métodos accesores  correspondientes.  (4) Compilar la clase destino.  (5) Determinar cómo hacer refe"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 33, "text": "“Encapsulamiento de campo”.  (2) Compilar y probar.  (3) Crear un campo en la clase destino con los métodos accesores  correspondientes.  (4) Compilar la clase destino.  (5) Determinar cómo hacer referencia a la clase destino desde el origen.  (6) Remover el campo de la clase origen.  (7) Reemplazar la referencia en la clase origen invocado el método accesor  correspondiente (Campo autoencapsulado)  (8) Compilar y probar.  Ejemplo          "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 34, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 34 de 45   II/DAS      Trabajando con cúmulos de datos    Preserve Whole Object: Preservación del objeto entero  Resumen  Se envía como parámetro un objeto.  Motivación  Se usan varios valores de un objeto y se pasan como parámetros en la llamada  de un método.  Mecanismo  (1) Crear un nuevo parámetro que permita enviar el objeto entero.  (2) Compilar y probar.  (3) Determinar qué parámetros pueden ser reemplazados por el objeto  entero.  (4) Tomar un parámetro y reemplazar las referencias al mismo dentro del  cuerpo del método invocado.  (5) Eliminar el parámetro.  (6) Compilar y probar.  (7) Repetir e"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 34, "text": "plazados por el objeto  entero.  (4) Tomar un parámetro y reemplazar las referencias al mismo dentro del  cuerpo del método invocado.  (5) Eliminar el parámetro.  (6) Compilar y probar.  (7) Repetir el procedimiento por cada parámetro que se pueda reemplazar  con el objeto entero.  (8) Quitar el código en el método de llamada que obtiene los parámetros  borrados.  (9) Compilar y probar.  Ejemplo  double cost = order.getTotal();  float weight = order.getWeight();  String destination = order.getPostalCode();    double shippingCost = calculateShipping(cost, weight, destination);      public double calculateShipping(cost, weight, destination) {    // ...  }          double shippingCost = calculateShipping(order);    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 34, "text": "e calculateShipping(cost, weight, destination) {    // ...  }          double shippingCost = calculateShipping(order);    "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 35, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 35 de 45   II/DAS      public double calculateShipping(Order order) {    // ...  }      Introduce Parameter Object: Introducir objeto como parámetro  Resumen  Reemplazar parámetro con un objeto.  Motivación  Se tiene un grupo de parámetros que están fuertemente relacionados.  Mecanismo  (1) Crear una nueva clase que represente el grupo de parámetros que está  relacionado.   (2) Compilar.  (3) Utilizar “Agregar parámetro” para el nuevo grupo de datos. Usar un  valor nulo para este parámetro en todas las llamadas al método.  (4) Para cada parámetro en el grupo de datos, eliminar el parámetro de la  firma "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 35, "text": "gar parámetro” para el nuevo grupo de datos. Usar un  valor nulo para este parámetro en todas las llamadas al método.  (4) Para cada parámetro en el grupo de datos, eliminar el parámetro de la  firma del método. Modificar la llamada al método para que utilice un  objeto.  (5) Recopilar y probar después de quitar cada parámetro.  (6) Una vez que se hayan eliminado los parámetros, buscar qué  comportamiento se puede mover dentro del parámetro objeto. Utilizar  “Mover método”.  Ejemplo  public void drawRectangle(int x, int y, int height, int width) {    // ...  }    public void drawEllipse(int x, int y, int height, int width) {    // ...  }    public void drawStar(int x, int y, int height, int width) {    // ...  }          class Frame {      private int x;    private int y;    private int he"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 35, "text": " int y, int height, int width) {    // ...  }    public void drawStar(int x, int y, int height, int width) {    // ...  }          class Frame {      private int x;    private int y;    private int height;    private int width;      // ...    }    public void drawRectangle(Frame frame) {    // ...  }  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 36, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 36 de 45   II/DAS      public void drawEllipse(Frame frame) {    // ...  }    public void drawStar(Frame frame) {    // ...  }    Refactorizaciones para simplificar llamado a métodos    Rename Method: Renombrado de método  Resumen  Se cambia el nombre del método. En este caso se sugiere  nombrar al método  de la misma forma que se hubiera comentado.  Motivación  El nombre del método no revela su propósito.  Mecanismo  (1) Revisar la firma del método para determinar si está implementada en  una superclase o subclase. Si esto se cumple, seguir los siguientes  pasos.  (2) Declarar un nuevo método con el nu"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 36, "text": " Mecanismo  (1) Revisar la firma del método para determinar si está implementada en  una superclase o subclase. Si esto se cumple, seguir los siguientes  pasos.  (2) Declarar un nuevo método con el nuevo nombre. Copiar el antiguo  cuerpo del código al nuevo método y hacer las modificaciones  necesarias para adaptarlo.  (3) Compilar.  (4) Cambiar el cuerpo del viejo método de modo que llame al nuevo.  (5) Compilar y probar.  (6) Encontrar todas las referencias al nombre antiguo del método y  cambiarlos por el nuevo. Compilar y probar después de cada cambio.  (7) Retirar el antiguo método.  (8) Compilar y probar.  Ejemplo              "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 36, "text": "Compilar y probar.  Ejemplo              "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 37, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 37 de 45   II/DAS    Add Parameter: Añadir parámetro  Resumen  Añadir un parámetro para que el objeto pueda transmitir más información.  Motivación  El método requiere más información de quién lo invoca.  Mecanismo  (1) Revisar la firma del método para determinar si está implementada en  una superclase o subclase. Si esto se cumple, seguir los siguientes  pasos.  (2) Declarar un nuevo método con el parámetro agregado. Copiar el antiguo  cuerpo de código al nuevo método.  (3) Compilar.  (4) Cambiar el cuerpo del viejo método de modo que llame al nuevo.  (5) Compilar y probar.  (6) Encontrar todas las ref"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 37, "text": "o agregado. Copiar el antiguo  cuerpo de código al nuevo método.  (3) Compilar.  (4) Cambiar el cuerpo del viejo método de modo que llame al nuevo.  (5) Compilar y probar.  (6) Encontrar todas las referencias al método antiguo y cambiarlas para  referirse al nuevo. Compilar y probar después de cada cambio.  (7) Retirar el antiguo método.  (8) Compilar y probar.  Ejemplo              Remove Parameter: Eliminar parámetro  Resumen  Se elimina parámetro sin uso.  Motivación  El parámetro no es utilizado en el cuerpo del método.  Mecanismo  (1) Revisar la firma del método para determinar si está implementada en  una superclase o subclase.   (2) Revisar si la clase o superclase utiliza el parámetro. Si lo hace, no hagas  esta refactorización.  (3) Declarar un nuevo método sin el parámetro. Copia"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 37, "text": "plementada en  una superclase o subclase.   (2) Revisar si la clase o superclase utiliza el parámetro. Si lo hace, no hagas  esta refactorización.  (3) Declarar un nuevo método sin el parámetro. Copiar el código en el  nuevo método.  (4) Compilar.  (5) Cambiar el cuerpo del viejo método de modo que llame al nuevo.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 38, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 38 de 45   II/DAS    (6) Compilar y probar.  (7) Encontrar todas las referencias al método antiguo y cambiarlas para  referirse al nuevo. Compilar y probar después de cada cambio.  (8) Retirar el antiguo método.  (9) Compilar y probar.  Ejemplo              Parameterize Method: Parametrizar método  Resumen  Se elimina parámetro sin uso.  Motivación  Varios métodos hacen cosas similares pero con valores distintos.  Mecanismo  (1) Crear un método con un parámetro que pueda sustituir cada método  repetitivo.  (2) Compilar.  (3) Reemplazar el antiguo método invocando al nuevo.  (4) Compilar y probar.  (5) R"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 38, "text": "intos.  Mecanismo  (1) Crear un método con un parámetro que pueda sustituir cada método  repetitivo.  (2) Compilar.  (3) Reemplazar el antiguo método invocando al nuevo.  (4) Compilar y probar.  (5) Repetir el procedimiento para todos los métodos. Probar después de  cada cambio.  Ejemplo          "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 39, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 39 de 45   II/DAS        Replace Parameter with Explicit Methods: Reemplazar parámetro con métodos explícitos  Resumen  Crear un método por cada valor posible del parámetro.  Motivación  Se tiene un método que ejecuta código diferente según el valor de uno de sus  parámetros.  Mecanismo  (1) Crear un método explícito por cada valor del parámetro.  (2) Para cada condicional, llamar al método creado previamente que  corresponda.  (3) Compilar y probar después de cada cambio.  (4) Reemplazar las llamadas al método condicional con la invocación al  método que corresponda.  (5) Compilar y probar.  (6) Cuando"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 39, "text": "te que  corresponda.  (3) Compilar y probar después de cada cambio.  (4) Reemplazar las llamadas al método condicional con la invocación al  método que corresponda.  (5) Compilar y probar.  (6) Cuando se cambien todas las llamadas al método condicional, eliminarlo.  Ejemplo  public void setValue (String name, int value) {    if (name.equals(\"height\"))      _height = value;    else if (name.equals(\"width\"))      _width = value;    Assert.shouldNeverReachHere();  }            public void setHeight(int arg) {    _height = arg;  }    public void setWidth (int arg) {    _width = arg;  }    Refactorizaciones que suben y bajan métodos y campos    Pull Up Field: Subir campo  Resumen  Mover el campo a la superclase.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 39, "text": "izaciones que suben y bajan métodos y campos    Pull Up Field: Subir campo  Resumen  Mover el campo a la superclase.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 40, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 40 de 45   II/DAS    Motivación  Dos subclases tienen un campo que significa lo mismo.  Mecanismo  (1) Revisar todos los usos de los campos candidatos para asegurarse de que  se utilizan de la misma manera.  (2) Si los campos no tienen el mismo nombre, cambiar el nombre de los  campos para que tengan el nombre que se desea utilizar en el campo de  la superclase.  (3) Compilar y probar.  (4) Crear un nuevo campo en la superclase.  (5) Eliminar los campos de las subclases.  (6) Compilar y probar.  (7) Considerar el uso de la refactorización de “Auto encapsulamiento de  campos” para el nuevo campo.  Ejempl"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 40, "text": "ampo en la superclase.  (5) Eliminar los campos de las subclases.  (6) Compilar y probar.  (7) Considerar el uso de la refactorización de “Auto encapsulamiento de  campos” para el nuevo campo.  Ejemplo                  Pull Up Method: Subir método  Resumen  Mover los métodos a la superclase.  Motivación  Se tienen métodos con iguales resultados en las subclases.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 41, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 41 de 45   II/DAS    Mecanismo  (1) Revisar los métodos para asegurarse de que son idénticos.  (2) Si los métodos tienen diferentes firmas, cambiar las firmas a la que se  desea utilizar en la superclase.  (3) Crear un nuevo método en la superclase, copiar el cuerpo de uno de los  métodos, ajustar, y compilar.  (4) Encapsular campo y declarar y utilizar un método get abstracto.  (5) Eliminar el método de la subclase.  (6) Compilar y probar.  (7) Borrar métodos de las subclases y probar hasta que sólo quede el  método de superclase.  (8) Revisar las llamadas al método para determinar si se requiere algún"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 41, "text": " subclase.  (6) Compilar y probar.  (7) Borrar métodos de las subclases y probar hasta que sólo quede el  método de superclase.  (8) Revisar las llamadas al método para determinar si se requiere algún  cambio.  Ejemplo              Push Down Field: Bajar campo  Resumen  Mover el campo a la subclase que requiere el mismo.  Motivación  Un campo que se utiliza solo en alguna subclase.  Mecanismo  (1) Declarar el campo en todas las subclases.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 42, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 42 de 45   II/DAS    (2) Retirar el campo de la superclase.  (3) Compilar y probar.  (4) Retirar el campo de todas las subclases que no lo necesitan.  (5) Compilar y probar.  Ejemplo              Push Down Method: Bajar método  Resumen  Mover el método a las subclases que correspondan.  Motivación  El comportamiento definido en la superclase es solo válido para algunas  subclases.  Mecanismo  (1) Declarar el método en todas las subclases y copiar el cuerpo en cada  subclase.  (2) Retirar el método de superclase.  (3) Compilar y probar.  (4) Retirar el método de cada subclase que no lo necesita.  (5) Com"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 42, "text": "l método en todas las subclases y copiar el cuerpo en cada  subclase.  (2) Retirar el método de superclase.  (3) Compilar y probar.  (4) Retirar el método de cada subclase que no lo necesita.  (5) Compilar y probar.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 43, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 43 de 45   II/DAS    Ejemplo          Bases de un proceso de refactorización    La refactorización como tal es una técnica aplicable a casi cualquier metodología de desarrollo  de software. Si bien es cierto que cada metodología particular puede tratarla de una manera  concreta (generalmente marcando cuándo y cuánto), existe una secuencia general e intrínseca  a la hora de refactorizar, similar a la siguiente (Wampler):    1° Revisar código y diseño para identificar refactorizaciones.    2° Aplicar refactorizaciones cada vez, sin cambiar la funcionalidad.    3° Aplicar pruebas unitarias, después de cada"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 43, "text": "te (Wampler):    1° Revisar código y diseño para identificar refactorizaciones.    2° Aplicar refactorizaciones cada vez, sin cambiar la funcionalidad.    3° Aplicar pruebas unitarias, después de cada refactorización sin excepción.    4° Repetir los pasos anteriores para encontrar más refactorizaciones que aplicar.    Además, existen algunas heurísticas a tener en cuenta durante el proceso:    -  No añadir funcionalidad a la vez que se refactoriza: La regla básica de la refactorización  es no cambiar la funcionalidad del código o su comportamiento observable  externamente. El programa debería comportarse exactamente de la misma forma antes  y después de la refactorización. Si el comportamiento cambia entonces será imposible  asegurar que la refactorización no ha estropeado lo que antes ya "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 43, "text": "comportarse exactamente de la misma forma antes  y después de la refactorización. Si el comportamiento cambia entonces será imposible  asegurar que la refactorización no ha estropeado lo que antes ya funcionaba.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 44, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 44 de 45   II/DAS      -  Uso estricto de las pruebas: Al realizar pruebas en cada paso se reduce el riesgo del  cambio, siendo este un requisito obligatorio tras la aplicación de cada refactorización  individual.    -   Refactorizar es aplicar muchas refactorizaciones simples: Cada refactorización  individual puede realizar un pequeño progreso, pero el efecto acumulativo de aplicar  muchas refactorizaciones resulta en una gran mejora de la calidad, legibilidad y diseño  del código.    Bad Smells y sus refactorizaciones más típicas    Bad Smell  Refactorizaciones más utilizadas  Atributo temporal  Extra"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 44, "text": "s resulta en una gran mejora de la calidad, legibilidad y diseño  del código.    Bad Smells y sus refactorizaciones más típicas    Bad Smell  Refactorizaciones más utilizadas  Atributo temporal  Extract class. Introduce null object.  Cadena de mensajes  Hide delegate.  Cambio divergente  Extract class.  Cambio en cadena  Move method. Move field. Inline class.  Clase de datos  Move method. Encapsulate field. Encapsulate collection.  Código muerto  Inline class. Collapse hierarchy. Remove parameter.  Clase grande  Extract class. Extract subclass. Extract interface. Replace data  value with object.  Clase perezosa  Inline class. Collapse hierarchy.  Comentarios  Extract method. Introduce assertion.  Duplicación de código  Extract method. Extract class. Pull up method. Form template  method.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 44, "text": "t.  Clase perezosa  Inline class. Collapse hierarchy.  Comentarios  Extract method. Introduce assertion.  Duplicación de código  Extract method. Extract class. Pull up method. Form template  method.  Envidia de  características  Move method. Move field. Extract method.  Estructuras de  agrupación condicional  Replace conditional with polymorphism. Replace type code with  subclasses. Replace type code with state/strategy. Replace  parameter with explicit methods. Introduce null object.  Generalidad  especulativa  Collapse hierarchy. Inline class. Remove parameter. Rename  method.  Grupos de datos  Extract class. Introduce parameter object. Preserve whole object.  Intermediario  Remove middleman. Inline method. Replace delegation with  inheritance.  Intimidad inadecuada  Move method. Move fi"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 44, "text": "os  Extract class. Introduce parameter object. Preserve whole object.  Intermediario  Remove middleman. Inline method. Replace delegation with  inheritance.  Intimidad inadecuada  Move method. Move field. Change bidirectional association to  unidirectional. Replace inheritance with delegation. Hide delegate.  "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 45, "text": "  INGENIERÍA EN INFORMÁTICA – PLAN 2014  DISEÑO AVANZADO SOFTWARE – 10° CUATRIMESTRE      APUNTE DE REFACTORIZACIÓN      VERSIÓN: 1.5  VIGENCIA: 11-10-2011    Lic. Mariela Pastarini  Página 45 de 45   II/DAS    Jerarquías paralelas  Move method. Move field.  Legado rechazado  Replace inheritance with delegation.  Lista de parámetros  larga  Replace parameter with method. Introduce parameter object.  Preserve whole object.  Método largo  Extract method. Replace temp with query. Replace method with  method object. Decompose conditional.  Obsesión primitiva  Replace data value with object. Extract class. Introduce parameter  object. Replace array with object. Replace type code with class.  Replace type code with subclasses. Replace type code with  state/strategy.  Clases alternativas con  dif"}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 45, "text": "t class. Introduce parameter  object. Replace array with object. Replace type code with class.  Replace type code with subclasses. Replace type code with  state/strategy.  Clases alternativas con  diferentes interfaces  Rename methods. Move method. Add parameter. Parameterize  method. Extract superclass.  Biblioteca de clases  incompleta  Introduce foreign method. Introduce local extension.    BIBLIOGRAFÍA    [Fowler99] Martin Fowler (1999). “Refactoring: Improving the design of existing code”  Addison-Wesley. USA  [Piattini03] Mario Piattini (2003). “Calidad en el desarrollo y mantenimiento del software”  Alfaomega. México    http://www.refactoring.com/                "}, {"title": "M1-5-Apunte-sobre-Refactorizacion-v1.5", "page": 45, "text": "el software”  Alfaomega. México    http://www.refactoring.com/                "}]