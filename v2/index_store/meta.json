[
  {
    "title": "Estimaci√≥n",
    "page": 1,
    "text": "ESTIMACI√ìN PARA PROYECTOS\nDE SOFTWARE"
  },
  {
    "title": "Estimaci√≥n",
    "page": 2,
    "text": "‚Ä¢ Fallar en la planificaci√≥n es uno de los errores\nm√°s importantes que un proyecto puede\ntener...\n‚Ä¢ La planificaci√≥n efectiva es necesaria para\nresolver problemas de manera temprana en el\nProyecto a bajo costo, en lugar de manera\ntard√≠a en el proyecto a alto costo."
  },
  {
    "title": "Estimaci√≥n",
    "page": 3,
    "text": "¬øQu√© involucra la Planificaci√≥n de\nproyectos de software?\nAbarca cinco actividades:\n1. Estimaci√≥n,\n2. Calendarizaci√≥n (fechas de entrega),\n3. An√°lisis de riesgos,\n4. Planificaci√≥n de gesti√≥n de la calidad y\n5. Planificaci√≥n de gesti√≥n del cambio."
  },
  {
    "title": "Estimaci√≥n",
    "page": 4,
    "text": "Antes de que el proyecto pueda\ncomenzar, el equipo de software debe:\nÔÉºEstimar el trabajo que se va a realizar,\nÔÉºLos recursos que se requerir√°n y\nÔÉºEl tiempo que transcurrir√° de principio a fin."
  },
  {
    "title": "Estimaci√≥n",
    "page": 5,
    "text": "Una vez completadas dichas actividades, el\nequipo de software debe:\n‚Ä¢ Establecer un calendario del proyecto que\ndefina las tareas e hitos de la ingenier√≠a de\nsoftware, que identifique qui√©n es\nresponsable de realizar cada tarea y\nespecifique las dependencias entre tareas que\npuedan imponer una fuerte demora sobre el\navance."
  },
  {
    "title": "Estimaci√≥n",
    "page": 6,
    "text": "¬øQu√© es la estimaci√≥n?\n‚Ä¢ Es el intento por determinar cu√°nto dinero,\nesfuerzo, recursos y tiempo tomar√° construir\nun sistema o producto espec√≠fico basado en\nsoftware."
  },
  {
    "title": "Estimaci√≥n",
    "page": 7,
    "text": "¬øCu√°les son los pasos generales?\n1. Descripci√≥n del √°mbito del problema. (Objetivo\ngeneral del sistema).\n2. Luego √©ste se descompone en un conjunto de\nproblemas m√°s peque√±os (requerimientos) y\n3. cada uno de √©stos se estima, usando como gu√≠as\ndatos hist√≥ricos y experiencia (m√©tricas).\n4. La complejidad y el riesgo del problema se\nconsideran antes de realizar una estimaci√≥n\nfinal."
  },
  {
    "title": "Estimaci√≥n",
    "page": 8,
    "text": "¬øQu√© afectan a la estimaci√≥n?\nComplejidad del\nproyecto\n‚Ä¢Experiencia del equipo\nGrado de\nincertidumbre\nestructural Tama√±o del\nproyecto\n‚Ä¢Entendimiento de los\nrequisitos. Divisi√≥n de\nfunciones"
  },
  {
    "title": "Estimaci√≥n",
    "page": 9,
    "text": "El riesgo de estimaci√≥n se mide por el grado de incertidumbre\nen las estimaciones cuantitativas establecidas para recursos,\ncosto y calendario.\nSi el √°mbito del proyecto se describe de manera pobre o si los\nrequisitos del proyecto est√°n sujetos a cambios, la incertidumbre\ny el riesgo en la estimaci√≥n se vuelven peligrosamente altos.\nSugerencia:\nÔÉº Con el cliente se deben reconocer que la variabilidad en los\nrequisitos del software significa inestabilidad en costo y\ntiempo de desarrollo.\nÔÉº Tomar una visi√≥n iterativa del desarrollo. Es decir, actualizar la\nestimaci√≥n (conforme se conoce m√°s informaci√≥n) ‚Äì No muy\naconsejable - y revisarla cuando el cliente hace cambios a los\nrequisitos."
  },
  {
    "title": "Estimaci√≥n",
    "page": 10,
    "text": "¬øEn qu√© se basa el √©xito de la\nestimaci√≥n?\nÔÉº El grado en el que se estim√≥ adecuadamente el\ntama√±o del producto que se va a construir,\nÔÉº La habilidad para traducir la estimaci√≥n de\ntama√±o en esfuerzo humano, tiempo calendario\ny dinero.\nÔÉº El grado en el que el plan del proyecto refleja las\nhabilidades del equipo de software y\nÔÉº La estabilidad de los requisitos del producto y el\nentorno que soporta el esfuerzo de ingenier√≠a de\nsoftware."
  },
  {
    "title": "Estimaci√≥n",
    "page": 11,
    "text": "¬øQu√© podemos utilizar para estimar\nproyectos de software?\nT√©cnicas de Modelos\ndescomposici√≥n emp√≠ricos"
  },
  {
    "title": "Estimaci√≥n",
    "page": 12,
    "text": "T√âCNICAS DE DESCOMPOSICI√ìN\n1. Dimensionar el software (Problema de\ndimensionamiento del software):\n1. Dimensionamiento de punto de funci√≥n\n2. Dimensionamiento de componente est√°ndar: se\nestima el tama√±o a trav√©s del n√∫mero de ocurrencias\nde c/componente y luego usa datos de proyecto\nhist√≥ricos para estimar el tama√±o entregado por\ncomponente est√°ndar (m√≥dulos, pantallas, reportes,\netc.).\n3. Dimensionamiento del cambio: Este enfoque se usa\ncuando un proyecto abarca el uso de software\nexistente que debe modificarse en alguna forma\ncomo parte de un proyecto. Se estima el n√∫mero y\ntipo de las modificaciones que deben lograrse."
  },
  {
    "title": "Estimaci√≥n",
    "page": 13,
    "text": "2. Estimaci√≥n basada en problema: A partir del\nenunciado del alcance del software\ndescomponer el enunciado en problemas\nque puedan estimarse cada uno de manera\nindividual. Puede elegir como componente\npara dimensionamiento, clases u objetos,\nm√≥dulos, cambios o procesos empresariales\nafectados. Luego calcular para cada problema\nel ‚Äúvalor esperado‚Äù para el tama√±o del\nsoftware:\nTama√±o esperado = (T + 4 T + T )/ 6\noptimista medio pesimista"
  },
  {
    "title": "Estimaci√≥n",
    "page": 14,
    "text": "3. Estimaci√≥n con casos de uso: se utiliza si para el\ndise√±o y desarrollo utilizo UML y RUP. Se basa en\nel m√©todo de PF.\nUtiliza actores y casos de uso relevados para\ncalcular el esfuerzo que significar√° desarrollarlos.\nA los casos de uso se les asigna una complejidad\nbasada en transacciones o clases de an√°lisis,\nmientras que a los actores se les asigna una\ncomplejidad basada en su tipo, es decir, si son\ninterfaces con usuarios u otros sistemas.\nTambi√©n se utilizan factores de entorno y de\ncomplejidad t√©cnica para ajustar el resultado."
  },
  {
    "title": "Estimaci√≥n",
    "page": 15,
    "text": "El objetivo de la t√©cnica\nde estimaci√≥n con casos de uso\n‚Ä¢ Estimar las horas necesarias para ejecutar un\nconjunto de casos de uso. Es decir,\nnecesitamos predecir cu√°nto tiempo llevar√° el\ndesarrollo de software y cu√°ntas personas se\nrequieren para realizarlo. Para ello, es\nnecesario cuantificar la complejidad del\nsistema y el tiempo necesario para producir\nuna unidad de complejidad."
  },
  {
    "title": "Estimaci√≥n",
    "page": 16,
    "text": "MODELOS DE ESTIMACI√ìN\nEMP√çRICOS\n‚Ä¢ Un modelo de estimaci√≥n refleja la poblaci√≥n de\nproyectos de los cuales se deriv√≥. Por tanto, el modelo\nes sensible al dominio.\n‚Ä¢ Un modelo de estimaci√≥n debe calibrarse para que\nrefleje las condiciones locales.\n‚Ä¢ El modelo debe probarse aplicando los datos\nrecopilados de los proyectos completados,\nalimentando los datos en el modelo y luego\ncomparando los resultados reales con los predichos. Si\nla concordancia es pobre, el modelo debe afinarse y\nvolverse a probar antes de poder usarse."
  },
  {
    "title": "Estimaci√≥n",
    "page": 17,
    "text": "Modelo COCOMO II\nCOnstructive COst MOdel: modelo constructivo de\ncostos http://softwarecost.org/tools/COCOMO\nEs un modelo emp√≠rico que se obtuvo recopilando\ndatos de varios proyectos grandes.\nEstos datos fueron analizados para descubrir las\nf√≥rmulas que mejor se ajustaban a las\nobservaciones. Estas f√≥rmulas vinculan el tama√±o\ndel sistema y del producto, factores del proyecto y\ndel equipo con el esfuerzo necesario para\ndesarrollar el sistema."
  },
  {
    "title": "Estimaci√≥n",
    "page": 18,
    "text": "Algunos modelos de estimaci√≥n\norientados a PF\n‚Ä¢ Modelo Albrecht y Gaffney:\n‚Ä¢ Esfuerzo = -91.4 + 0.355 * PF\n‚Ä¢ Modelo Kemerer:\n‚Ä¢ Esfuerzo= -37 + 0.96 * PF\n‚Ä¢ Peque√±o modelo de regresi√≥n de proyecto:\n‚Ä¢ Esfuerzo= -12.88 + 0.405 PF\n‚Ä¢ Es claro que cada uno producir√° un resultado diferente\npara los mismos valores de PF. Por tal motivo\n¬°Los modelos de estimaci√≥n deben calibrarse para las\nnecesidades locales!"
  },
  {
    "title": "Estimaci√≥n",
    "page": 19,
    "text": "Estimaci√≥n para\ndesarrollo √°gil"
  },
  {
    "title": "Estimaci√≥n",
    "page": 20,
    "text": "‚Ä¢ La estimaci√≥n √°gil es un trabajo en equipo\n‚Ä¢ Cada miembro del equipo aporta una\nperspectiva diferente sobre el producto y el\ntrabajo necesario para entregar una historia\nde usuario."
  },
  {
    "title": "Estimaci√≥n",
    "page": 21,
    "text": "Usa un enfoque de descomposici√≥n,\ncon los siguientes pasos:\n1. Cada historia de usuario (el equivalente de un minicaso de uso\ncreado al comienzo de un proyecto por los usuarios finales u otros\nparticipantes) se considera por separado con prop√≥sitos de\nestimaci√≥n.\n2. La historia de usuario se descompone en el conjunto de tareas de\ningenier√≠a de software que ser√° necesario desarrollar.\n3. El esfuerzo requerido por cada tarea se estima por separado.\n4. Las estimaciones para cada tarea se suman a fin de crear una\nestimaci√≥n para la historia de usuario.\n5. Las estimaciones de esfuerzo para todos los escenarios (historias\nde usuario) que se implementan para un incremento de software\ndeterminado se suman a fin de desarrollar la estimaci√≥n del\nesfuerzo para el incremento."
  },
  {
    "title": "Estimaci√≥n",
    "page": 22,
    "text": "¬øEn qu√© momento se realiza la estimaci√≥n\nen Scrum?\nDurante el Sprint Planning. Es la etapa de reuni√≥n\ninicial, donde todo el equipo se prepara para el Sprint\nque est√° por comenzar.\nEl equipo de desarrollo se sienta junto al Product\nOwner y al Srum Master, en la sesi√≥n de planificaci√≥n.\nSe presentar√°n los PBI (Product Backlogs Items) y se\neligen los elementos seg√∫n la prioridad y asocia una\nestimaci√≥n de tiempo y esfuerzo."
  },
  {
    "title": "Estimaci√≥n",
    "page": 23,
    "text": "Matriz de Eisenhower"
  },
  {
    "title": "Estimaci√≥n",
    "page": 24,
    "text": "Urgente e Importante (Hacer) Importante pero no Urgente\nEjemplo: Un error cr√≠tico en la aplicaci√≥n (Programar)\nque causa un fallo total y afecta a los\nEjemplo: Implementar una nueva\nusuarios.\nfuncionalidad en la aplicaci√≥n que\nAcci√≥n: Resolver el error de inmediato, ya\nmejorar√° la experiencia del usuario, pero\nque el fallo es urgente y causa un impacto\nno es esencial para el lanzamiento actual.\nnegativo en los usuarios.\nAcci√≥n: Programar la implementaci√≥n\npara un futuro cercano, asegurando que\nse realice a tiempo para no afectar el\nlanzamiento.\nUrgente pero no Importante No Urgente y No Importante\n(Delegar) (Eliminar)\nEjemplo: Una solicitud de cambio menor Ejemplo: Requisitos de software que son\no una correcci√≥n de errores que, aunque considerados triviales o que no aportan\nurgentes, no so"
  },
  {
    "title": "Estimaci√≥n",
    "page": 24,
    "text": "ante\n(Delegar) (Eliminar)\nEjemplo: Una solicitud de cambio menor Ejemplo: Requisitos de software que son\no una correcci√≥n de errores que, aunque considerados triviales o que no aportan\nurgentes, no son cr√≠ticas para el √©xito del valor significativo al producto.\nproducto. Acci√≥n: Eliminar o posponer estos\nAcci√≥n: Delegar la tarea a un miembro del requerimientos hasta que sean necesarios\nequipo o un tercero que pueda realizarla o que se comprenda su valor real.\nr√°pidamente."
  },
  {
    "title": "Estimaci√≥n",
    "page": 25,
    "text": "Algunos m√©todos de estimaci√≥n √°gil\nEstimaci√≥n en Scrum Delphi Story Points\n‚Ä¢ El grupo estima el esfuerzo ‚Ä¢ Se da puntos a cada historia de\nan√≥nimamente de un √≠tem del usuario, o elemento del backlog,\nBacklog. Se repite hasta que las seg√∫n su nivel de dificultad.\nestimaciones del equipo est√©n cerca\nunas de otras, y se pueda llegar a un\nconsenso para la estimaci√≥n final.\nPlanning Poker T√©cnica de las camisetas\n‚Ä¢ Similar a Delphi, solo que se utilizan ‚Ä¢ Si consideran que una actividad es\ncartas con n√∫meros que suelen compleja, la colocar√°n con el\nestar en la secuencia de Fibonacci: tama√±o XL. En cambio, una\n0, 1, 2, 3, 5, 8, 13 y 21. actividad que consideren sencilla,\npuede colocarse en la categor√≠a de\nXS."
  },
  {
    "title": "Estimaci√≥n",
    "page": 26,
    "text": "La estimaci√≥n de proyecto de software\nnunca puede ser una ciencia exacta,\npero una combinaci√≥n de buenos\ndatos hist√≥ricos y t√©cnicas sistem√°ticas\npueden mejorar la precisi√≥n de la\nestimaci√≥n."
  },
  {
    "title": "Metricas",
    "page": 1,
    "text": "M√©tricas, medidas y mediciones\ndel software"
  },
  {
    "title": "Metricas",
    "page": 2,
    "text": "Medida Medici√≥n M√©trica\nEs una medida\ncuantitativa del grado\nEs el acto de\nen el que un sistema,\ndeterminar una\nProporciona un indicio componente o\nmedida.\ncuantitativo de la proceso posee un\nLa medici√≥n ocurre\nextensi√≥n, cantidad, atributo\ncomo resultado de la\ncapacidad o tama√±o de determinado.\nrecolecci√≥n de uno o\nalg√∫n atributo de un\nEj: el n√∫mero\nm√°s puntos de datos.\nproducto o proceso.\npromedio de errores\nEj: recolectar medidas\nEj: cantidad de errores que se encuentran\ndel n√∫mero de\nen un componente de por revisi√≥n o el\nerrores de un\nsw n√∫mero promedio de\ncomponente y una\nerrores que se\nprueba de unidad.\nencuentran por\nunidad de prueba."
  },
  {
    "title": "Metricas",
    "page": 3,
    "text": "‚Ä¢ Un ingeniero de software recolecta medidas y\ndesarrolla m√©tricas de modo que se obtengan\nindicadores.\n‚Ä¢ Un indicador es una m√©trica o combinaci√≥n de\nm√©tricas que proporcionan comprensi√≥n\nacerca del proceso de software, el proyecto de\nsoftware o el producto en s√≠.\n‚Ä¢ Permite ajustar el proceso, el proyecto o el\nproducto para hacer mejor las cosas."
  },
  {
    "title": "Metricas",
    "page": 4,
    "text": "¬øPor qu√© es importante medir?\n‚Ä¢ Siempre habr√° un elemento cualitativo en la creaci√≥n del\nsoftware. El problema es que la valoraci√≥n cualitativa tal\nvez no sea suficiente.\n‚Ä¢ Se necesitan criterios objetivos que ayuden a guiar el\ndise√±o de datos, arquitectura, interfaces y componentes.\n‚Ä¢ Cuando se prueban, es necesaria la gu√≠a cuantitativa que\nayuda en la selecci√≥n de los casos de prueba y de sus\nobjetivos. Las m√©tricas de producto proporcionan una\nbase desde donde el an√°lisis, el dise√±o, la codificaci√≥n y\nlas pruebas pueden realizarse de manera m√°s objetiva y\nvalorarse de modo m√°s cuantitativo."
  },
  {
    "title": "Metricas",
    "page": 5,
    "text": "¬øCu√°les son los pasos de un proceso de\nmedici√≥n efectivo?\n1. Formulaci√≥n. La derivaci√≥n de medidas y m√©tricas de\nsoftware apropiadas para la representaci√≥n del software\nque se est√° construyendo.\n2. Recolecci√≥n. Mecanismo que se usa para acumular datos\nrequeridos para derivar las m√©tricas formuladas.\n3. An√°lisis. El c√°lculo de m√©tricas y la aplicaci√≥n de\nherramientas matem√°ticas.\n4. Interpretaci√≥n. Evaluaci√≥n de las m√©tricas resultantes para\ncomprender la calidad de la representaci√≥n.\n5. Retroalimentaci√≥n. Recomendaciones derivadas de la\ninterpretaci√≥n de las m√©tricas del producto, transmitidas al\nequipo de software."
  },
  {
    "title": "Metricas",
    "page": 6,
    "text": "Paradigma Meta/Pregunta/M√©trica\n(MPM)\n‚Ä¢ Es una t√©cnica para identificar m√©tricas\nsignificativas para cualquier parte del proceso de\nsoftware.\n1. Establecer una meta de medici√≥n explicita que\nsea especifica para la actividad del proceso o\npara la caracter√≠stica del producto que se quiera\nvalorar,\n2. Definir un conjunto de preguntas que deban\nresponderse con la finalidad de lograr la meta y\n3. identificar m√©tricas bien formuladas que ayuden\na responder dichas preguntas."
  },
  {
    "title": "Metricas",
    "page": 7,
    "text": "‚Ä¢ Meta:\nAumentar el tr√°fico del sitio web a 25.000 visitas\nen el segundo trimestre."
  },
  {
    "title": "Metricas",
    "page": 8,
    "text": "Preguntas:\n‚Ä¢ ¬øCu√°ntas visitas se obtuvo en el ultimo mes?\n‚Ä¢ ¬øSe realizan actualizaciones constantes de contenido en el sitio?\n‚Ä¢ ¬øSe realizan campa√±as de promoci√≥n en diferentes plataformas?\nEjemplo de m√©tricas:\n‚Ä¢ P√°ginas vistas √∫nicas del sitio web (n√∫mero de visitas) en un mes\n‚Ä¢ Cantidad promedio de actualizaci√≥n de contenidos durante un mes\n‚Ä¢ Cantidad de campa√±as realizadas en el primer trimestre\n‚Ä¢ Rango de edades del publico objetivo realizado en campa√±as\n‚Ä¢ Cantidad de regiones que alcanzan las campa√±as\n‚Ä¢ Tiempo promedio de duraci√≥n de las campa√±as"
  },
  {
    "title": "Metricas",
    "page": 9,
    "text": "Atributos de las m√©tricas de software\nefectivas\n1. Simple y calculable. Debe ser relativamente f√°cil aprender\nc√≥mo derivar la m√©trica y su c√°lculo no debe demandar\nesfuerzo o tiempo excesivo.\n2. Emp√≠rica e intuitivamente convincente. Debe satisfacer\nlas nociones intuitivas del ingeniero acerca del atributo de\nproducto que se elabora (por ejemplo, una m√©trica que\nmide la cohesi√≥n del m√≥dulo debe aumentar en valor\nconforme aumenta el nivel de cohesi√≥n).\n3. Congruente y objetiva. Siempre debe producir resultados\nque no tengan ambig√ºedades. Una tercera parte\nindependiente debe poder derivar el mismo valor de\nm√©trica usando la misma informaci√≥n acerca del software."
  },
  {
    "title": "Metricas",
    "page": 10,
    "text": "Atributos de las m√©tricas de software\nefectivas\n4. Constante en su uso de unidades y dimensiones. El c√°lculo\nmatem√°tico de la m√©trica debe usar medidas que no conduzcan a\ncombinaciones extra√±as de unidades. Por ejemplo, multiplicar\npersonas en los equipos de proyecto por variables de lenguaje de\nprogramaci√≥n en el programa da como resultado una mezcla\nsospechosa de unidades que no son intuitivamente convincentes.\n5. Independiente del lenguaje de programaci√≥n. Debe basarse en el\nmodelo de requerimientos, el modelo de dise√±o o la estructura\ndel programa en s√≠. No debe depender de la sintaxis o de la\nsem√°ntica del lenguaje de programaci√≥n.\n6. Un mecanismo efectivo para retroalimentaci√≥n de alta calidad.\nDebe proporcionar informaci√≥n que pueda conducir a un producto\nfinal de mayor calidad."
  },
  {
    "title": "Metricas",
    "page": 11,
    "text": "M√©tricas para el modelo de\nrequerimientos\nExaminan el modelo de requerimientos con la\nintenci√≥n de predecir el ‚Äútama√±o‚Äù del sistema\nresultante. En ocasiones, el tama√±o es un indicador de\nla complejidad del dise√±o y casi siempre es un\nindicador creciente de codificaci√≥n, integraci√≥n y\nesfuerzo de pruebas."
  },
  {
    "title": "Metricas",
    "page": 12,
    "text": "M√©trica basada en funciones\n‚Ä¢ La m√©trica de punto de funci√≥n (PF) puede\nusarse de manera efectiva como medio para\nmedir la funcionalidad que entra a un sistema.\n‚Ä¢ La m√©trica PF puede usarse para:\n‚Äì Estimar el costo o esfuerzo requerido para dise√±ar,\ncodificar y probar el software.\n‚Äì Predecir el n√∫mero de errores que se encontrar√°n\ndurante las pruebas, y\n‚Äì Prever el n√∫mero de componentes y/o de l√≠neas de\nc√≥digo proyectadas en el sistema implementado."
  },
  {
    "title": "Metricas",
    "page": 13,
    "text": "‚Ä¢ Los puntos de funci√≥n se derivan usando una\nrelaci√≥n emp√≠rica basada en medidas\ncontables del dominio de informaci√≥n del\nsoftware y en valoraciones cualitativas de la\ncomplejidad del software."
  },
  {
    "title": "Metricas",
    "page": 14,
    "text": "Los valores de dominio de informaci√≥n son:\n‚Ä¢ N√∫mero de entradas externas (EE). Cada entrada externa se origina de un usuario\no se transmite desde otra aplicaci√≥n, y proporciona distintos datos orientados a\naplicaci√≥n o informaci√≥n de control. Con frecuencia, las entradas se usan para\nactualizar archivos l√≥gicos internos (ALI). Las entradas deben distinguirse de las\nconsultas, que se cuentan por separado. Ej: ABM, pantallas en donde el usuario\ningresa datos.\n‚Ä¢ N√∫mero de salidas externas (SE). Cada salida externa son datos derivados dentro\nde la aplicaci√≥n que ofrecen informaci√≥n al usuario. En este contexto, salida\nexterna se refiere a reportes, env√≠o de notificaci√≥n, mensajes de error, etc.\n‚Ä¢ N√∫mero de consultas externas (CE). Una consulta externa se define como una\nentrada en l√≠nea que da"
  },
  {
    "title": "Metricas",
    "page": 14,
    "text": "este contexto, salida\nexterna se refiere a reportes, env√≠o de notificaci√≥n, mensajes de error, etc.\n‚Ä¢ N√∫mero de consultas externas (CE). Una consulta externa se define como una\nentrada en l√≠nea que da como resultado la generaci√≥n de alguna respuesta de\nsoftware inmediata en la forma de una salida en l√≠nea (con frecuencia recuperada\nde un ALI).\n‚Ä¢ N√∫mero de archivos l√≥gicos internos (ALI). Cada archivo l√≥gico interno es un\nagrupamiento l√≥gico de datos que reside dentro de la frontera de la aplicaci√≥n y se\nmantiene mediante entradas externas. Ej: tabla de la base de datos.\n‚Ä¢ N√∫mero de archivos de interfaz externos (AIE). Cada archivo de interfaz externo\nes un agrupamiento l√≥gico de datos que reside fuera de la aplicaci√≥n, pero que\nproporciona informaci√≥n que puede usar la aplicaci√≥n. Ej: Api "
  },
  {
    "title": "Metricas",
    "page": 14,
    "text": " interfaz externos (AIE). Cada archivo de interfaz externo\nes un agrupamiento l√≥gico de datos que reside fuera de la aplicaci√≥n, pero que\nproporciona informaci√≥n que puede usar la aplicaci√≥n. Ej: Api externas."
  },
  {
    "title": "Metricas",
    "page": 15,
    "text": "Usuario\nConsultas Externas\nConsultas\nEntradas Archivos\nOtra aplicaci√≥n\nExternas L√≥gicos\nUsuario Archivos de Interfaz\nInternos\nExterna\nSistema\nSalidas Externas"
  },
  {
    "title": "Metricas",
    "page": 16,
    "text": "‚Ä¢ Una vez recolectados dichos datos, se completa la siguiente\ntabla y un valor de complejidad se asocia con cada conteo. Por\n: ¬´\nejemplo Funci√≥n de interacci√≥n con el usuario de un sw¬ª."
  },
  {
    "title": "Metricas",
    "page": 17,
    "text": "‚Ä¢ Las organizaciones que usan m√©todos de\npunto de funci√≥n desarrollan criterios para\ndeterminar si una entrada particular es\nsimple, promedio o compleja.\n‚Ä¢ No obstante, la determinaci√≥n de complejidad\nes un tanto subjetiva."
  },
  {
    "title": "Metricas",
    "page": 18,
    "text": "Para calcular puntos de funci√≥n (PF), se usa la\nsiguiente relaci√≥n:\n‚Ä¢ Los valores constantes en la ecuaci√≥n y los factores\nponderados que se aplican a los conteos de dominio de\ninformaci√≥n se determinan de manera emp√≠rica.\n‚Ä¢ Factor de complejidad t√©cnica es todo lo que se encuentra\nentre [].\n‚Ä¢ F (i = 1 a 14): son factores de ajuste de valor (FAV) con base\ni\nen respuestas a las siguientes preguntas, cada una de estas\npreguntas se responde usando una escala que var√≠a de 0\n(no importante o no aplicable) a 5 (absolutamente\nesencial)."
  },
  {
    "title": "Metricas",
    "page": 20,
    "text": "1. ¬øEl sistema requiere respaldo y\nrecuperaci√≥n confiables? ‚Ä¢ Comunicaci√≥n de datos\n2. ¬øSe requieren comunicaciones\nde datos especializadas para\ntransferir informaci√≥n hacia o\ndesde la aplicaci√≥n?\n3. ¬øExisten funciones de\n‚Ä¢ Procesamiento Distribuido\nprocesamiento distribuidas?\n‚Ä¢ Objetivos de rendimiento\n4. ¬øEl desempe√±o es crucial?\n‚Ä¢ Configuraci√≥n del equipo\n5. ¬øEl sistema correr√° en un\nentorno operativo existente\nenormemente utilizado?\n6. ¬øEl sistema requiere entrada de ‚Ä¢ Entrada de datos en l√≠nea.\ndatos en l√≠nea?\n7. ¬øLa entrada de datos en l√≠nea\nrequiere que la transacci√≥n de\n‚Ä¢ Tasa de transacciones. Interfaz\nentrada se construya sobre\ncon el usuario.\nm√∫ltiples pantallas u\noperaciones?"
  },
  {
    "title": "Metricas",
    "page": 21,
    "text": "‚Ä¢ Actualizaciones en l√≠nea.\n8. ¬øLos ALI se actualizan en\nl√≠nea?\n9. ¬øLas entradas, salidas, ‚Ä¢ Procesamiento complejo\narchivos o consultas son\ncomplejos?\n10. ¬øEl procesamiento interno es\ncomplejo?\n11. ¬øEl c√≥digo se dise√±a para ser\n‚Ä¢ Reusabilidad del c√≥digo.\nreutilizable?\n‚Ä¢ Facilidad de implementaci√≥n\n12. ¬øLa conversi√≥n y la\ninstalaci√≥n se incluyen en el\ndise√±o?\n13. ¬øEl sistema se dise√±a para\n‚Ä¢ Instalaciones m√∫ltiples\ninstalaciones m√∫ltiples en\ndiferentes organizaciones?\n14. ¬øLa aplicaci√≥n se dise√±a para\n‚Ä¢ Facilidad de cambios y de\nfacilitar el cambio y su uso\noperaci√≥n.\npor parte del usuario?"
  },
  {
    "title": "Metricas",
    "page": 22,
    "text": "Supongamos que Fi es 46 (un producto moderadamente complejo).\nEl equipo del proyecto puede estimar el tama√±o global implementado de\nla ¬´funci√≥n de interacci√≥n del usuario¬ª.\nNota: los puntos de funci√≥n pueden calcularse a partir de diagrama de\nflujo de datos, de clases UML y diagramas de secuencia.\nIFPUG(InterntionalFunction Point Users\nGroup)"
  },
  {
    "title": "Metricas",
    "page": 23,
    "text": "Tabla IFPUG (International Function Point Users Group)\nLenguaje HS promedio por PF L√≠neas de c√≥digo por PF\nEnsamblador 25 300\n2¬™ y 3¬™ Generaci√≥n 15 100\n(COBOL, FORTRAN, PASCAL\ny MODULA)\n4¬∫ Generaci√≥n (Java, C#, 8 20\nPython, PHP, JS, etc.)"
  },
  {
    "title": "Metricas",
    "page": 24,
    "text": "Ejercicio 1\n‚Ä¢ Estimar mediante la m√©trica de punto de funci√≥n:\n1. El esfuerzo del proyecto inform√°tico (H/P).\nConsidere 8 horas promedio por punto de\nfunci√≥n.\n2. Duraci√≥n en meses del proyecto. Considere 8\nhoras diarias, 20 d√≠as al mes.\n3. Costo del proyecto inform√°tico. Considere:\n1. Sueldo por desarrollador= $400000\n2. Otros costos = $1.000.000"
  },
  {
    "title": "Metricas",
    "page": 25,
    "text": "Se consideran que las siguientes funciones son de\ncomplejidad media y que el factor de ajuste es de 32:\n1. Registrar clientes\n2. Registrar ventas\n3. Buscar ventas por fecha\n4. Actualizar datos del cliente\n5. Eliminar cliente\n6. Enviar notificaci√≥n de promociones a clientes\n7. 1 reporte de los clientes registrados por rango de\nfechas\n8. 1 reporte de ventas\n9. 4 tablas en BD (Cliente, Venta, DetVta y Producto)"
  },
  {
    "title": "Metricas",
    "page": 26,
    "text": "Soluci√≥n\n‚Ä¢ Horas/hombre = 72,75 * 8 = 582 horas/persona\n‚Ä¢ Duraci√≥n= 582/8 hs diarias de trabajo= 72,75 d√≠as\n‚Äì Si considero 20 d√≠as al mes = 72,75/20 = 3,64\nmeses/persona\n‚Äì Aproximado 3,64 meses por desarrollador.\n‚Äì Si tengo 2 desarrolladores = 1,82 meses/desarrollador\n‚Ä¢ Presupuesto\n‚Äì Sueldo por desarrollador= $400000\n‚Äì Otros costos = $1.000.000\n‚Äì CT= (n¬∫ desarrolladores * sueldo * tiempo) + otros costos =\n(2* $400000 *1,82) + $1.000.000 = $2.455.000"
  },
  {
    "title": "Metricas",
    "page": 27,
    "text": "Ejercicio 2\n‚Ä¢ Un sistema tiene 15 entradas externas, 24\nsalidas externas, presenta 0 diferentes\nconsultas externas, gestiona 4 archivos l√≥gicos\ninternos y tiene interfaz con 6 diferentes\nsistemas legados (6 AIE). Todos estos datos\nson de complejidad promedio (tomar tabla de\nponderaci√≥n) y el sistema global es\nrelativamente simple (Fi = 25). Calcule PF para\nel sistema."
  },
  {
    "title": "Metricas",
    "page": 28,
    "text": "M√©tricas para calidad de la\nespecificaci√≥n\n‚Ä¢ Se propone una lista de caracter√≠sticas que\npueden usarse para valorar la calidad del\nmodelo de requerimientos y la correspondiente\nespecificaci√≥n de requerimientos:\n‚Ä¢ Especificidad (falta de ambig√ºedad), completitud,\ncorrecci√≥n, comprensibilidad, verificabilidad,\nconsistencia interna y externa, factibilidad,\nconcisi√≥n, rastreabilidad, modificable, precisi√≥n y\nreusabilidad."
  },
  {
    "title": "Metricas",
    "page": 29,
    "text": "CARACTER√çSTICAS DESEABLES DE UNA\nERS\n‚Ä¢ No ambigua: La ERS es no ambigua si todo requisito posee una sola\ninterpretaci√≥n.\n‚Ä¢ Completa: Una ERS es completa si todo lo que se supone que el software\ndebe hacer est√° incluido en la ERS. Por completitud, deber√≠an describirse\ntodas las posibles respuestas a todas las posibles entradas y en todas las\nsituaciones posibles. Contemplar todos los escenarios posibles.\n‚Ä¢ Correcta: Todo requisito de la ERS contribuye a satisfacer una necesidad real.\n‚Ä¢ Comprensible: Todo tipo de lectores (clientes, usuarios, desarrolladores,\nequipo de pruebas, gestores, etc.) entienden la ERS.\n‚Ä¢ Verificable: Si para cada requisito expresado en la ERS existe un\nprocedimiento de prueba finito y no costoso para demostrar que el futuro\nsistema lo satisface.\n‚Ä¢ Internamente Consi"
  },
  {
    "title": "Metricas",
    "page": 29,
    "text": "ntienden la ERS.\n‚Ä¢ Verificable: Si para cada requisito expresado en la ERS existe un\nprocedimiento de prueba finito y no costoso para demostrar que el futuro\nsistema lo satisface.\n‚Ä¢ Internamente Consistente: No existen subconjuntos de requisitos\ncontradictorios.\n‚Ä¢ Externamente Consistente: Ninguno de los requisitos est√° en contradicci√≥n\ncon lo expresado en documentos de nivel superior. Por ejemplo, en un\nsistema (hardware+software), los requisitos del software no pueden\ncontradecir los requisitos del sistema."
  },
  {
    "title": "Metricas",
    "page": 30,
    "text": "CARACTER√çSTICAS DESEABLES DE UNA\nERS\n‚Ä¢ Factible: Si, dados los actuales recursos, la ERS se puede implementar.\n‚Ä¢ Concisa: La ERS debe ser lo m√°s breve posible, sin que esto afecte al resto\nde atributos de calidad.\n‚Ä¢ Independiente del dise√±o: Existen m√°s de un dise√±o e implementaci√≥n\nque realizan la ERS. Para ello la ERS deber√≠a limitarse a describir el\ncomportamiento externo del sistema.\n‚Ä¢ Trazable: Cada requisito se puede referenciar de forma un√≠voca. Es\nfundamental para precisar qu√© requisitos son implementados por qu√©\ncomponente del dise√±o, lo cual es imprescindible a la hora de realizar las\npruebas de dicho componente.\n‚Ä¢ Modificable: Los cambios son f√°ciles de introducir. Determinar un nivel de\ncambio a cada requerimiento (bajo, medio, alto).\n‚Ä¢ Precisa: Una ERS es precisa si hace uso d"
  },
  {
    "title": "Metricas",
    "page": 30,
    "text": "s\npruebas de dicho componente.\n‚Ä¢ Modificable: Los cambios son f√°ciles de introducir. Determinar un nivel de\ncambio a cada requerimiento (bajo, medio, alto).\n‚Ä¢ Precisa: Una ERS es precisa si hace uso de valores num√©ricos para precisar\nlas caracter√≠sticas del sistema. La precisi√≥n es aplicable, ante todo, a los\nrequisitos no funcionales.\n‚Ä¢ Reutilizable: Si ciertas secciones de la ERS se pueden reutilizar."
  },
  {
    "title": "Metricas",
    "page": 31,
    "text": "‚Ä¢ Cada una puede representarse usando una o\nm√°s m√©tricas. Por ejemplo, se supone que\nexisten nr requerimientos en una\nespecificaci√≥n, tales que nr = nf + nnf\n‚Ä¢ donde nf es el n√∫mero de requerimientos\nfuncionales y nnf es el n√∫mero de\nrequerimientos no funcionales (por ejemplo,\nrendimiento)."
  },
  {
    "title": "Metricas",
    "page": 32,
    "text": "Especificidad (falta de ambig√ºedad) de los\nrequerimientos:\n‚Ä¢ Q1 = nui/nr\n‚Ä¢ donde nui es el n√∫mero de requerimientos\npara los cuales todos los revisores tienen\ninterpretaciones id√©nticas.\n‚Ä¢ Mientras m√°s cercano a 1 est√© el valor de Q,\nmenor ser√° la ambig√ºedad de la\nespecificaci√≥n."
  },
  {
    "title": "Metricas",
    "page": 33,
    "text": "La completitud de los requerimientos funcionales\n‚Ä¢ Puede determinarse al calcular la raz√≥n:\n‚Ä¢ Q2= nu / (ni x ns)\n‚Ä¢ donde nu es el n√∫mero de requerimientos funcionales\n√∫nicos, ni es el n√∫mero de entradas (est√≠mulos) definidas o\nimplicadas por la especificaci√≥n y ns es el n√∫mero de\nestados especificados.\n‚Ä¢ La raz√≥n Q2 mide el porcentaje de funciones necesarias\nque se especificaron para un sistema.\n‚Ä¢ Sin embargo, no aborda requerimientos no funcionales.\n‚Ä¢ Para ello se usa Q3 = nc /(nc + nnv)\ndonde nc es el numero de requerimientos que se validaron\ncomo correctos y nnv es el numero de requerimientos que no\nse han validado."
  },
  {
    "title": "Metricas",
    "page": 34,
    "text": "M√©tricas para especificar requerimientos no\nfuncionales:"
  },
  {
    "title": "Metricas",
    "page": 35,
    "text": "M√âTRICAS PARA EL MODELO DE\nDISE√ëO\n‚ÄúLa arquitectura de un sistema\nes un marco general que describe\nsu forma y estructura: sus\ncomponentes y la manera en la\nque ajustan entre s√≠‚Äù.\nJerrold Grochow"
  },
  {
    "title": "Metricas",
    "page": 36,
    "text": "‚Ä¢ Del dise√±o arquitect√≥nico\nM√âTRICAS\n‚Ä¢ Para el dise√±o OO\n‚Ä¢ orientadas a clase: suite CK\nPARA EL\n‚Ä¢ orientadas a clase: suite MOOD\nMODELO\n‚Ä¢ O.O propuestas por Lorenz y Kidd\n‚Ä¢ De dise√±o en el nivel de\nDE\ncomponente\nDISE√ëO\n‚Ä¢ Orientadas a operaci√≥n\n‚Ä¢ De dise√±o de IU"
  },
  {
    "title": "Metricas",
    "page": 37,
    "text": "M√©tricas del dise√±o arquitect√≥nico\n‚Ä¢ Se enfocan en caracter√≠sticas de la\narquitectura del programa con √©nfasis en la\nestructura arquitect√≥nica y en la efectividad\nde los m√≥dulos o componentes dentro de la\narquitectura.\n‚Ä¢ Dichas m√©tricas son ‚Äúcaja negra‚Äù en tanto no\nrequieren conocimiento alguno del\nfuncionamiento interior de un componente de\nsoftware particular."
  },
  {
    "title": "Metricas",
    "page": 38,
    "text": "Se pueden definir 3 medidas de complejidad del dise√±o de\nsoftware: complejidad estructural, complejidad de datos y\ncomplejidad del sistema.\nPor ejemplo para arquitecturas jer√°rquicas, la complejidad\nestructural de un m√≥dulo i se define de la forma:\n‚Ä¢ S(i) = f2 (i)\nout\n‚Ä¢ donde f (i) es el fan-out del m√≥dulo i.\nout\n‚Ä¢ Fan-out: es el n√∫mero de m√≥dulos que invoca\ndirectamente el modulo i.\nPor ejemplo el m√≥dulo clientes invoca a los m√≥dulos ventas\ny suscripci√≥n.\nEntonces la complejidad del m√≥dulo clientes es:\nS(clientes) = 22 = 4"
  },
  {
    "title": "Metricas",
    "page": 39,
    "text": "La complejidad de datos ofrece un indicio de la\ncomplejidad que hay en la interfaz interna para un modulo i\ny se define como:\n‚Ä¢ D(i) = v(i) / f (i) + 1\nout\n‚Ä¢ donde v(i) es el numero de variables de entrada y salida\nque pasan hacia y desde el modulo i.\nPor ejemplo, v(i) = 21\nD(clientes) = 21 / (2+1) = 21/3 = 7\nLa complejidad del sistema se define como la suma de las\ncomplejidades estructural y de datos y se especifica como:\n‚Ä¢ C(i) = S(i) + D(i)\nPara nuestro simple ejemplo:\nC(clientes)= 4 + 21/3 = 11"
  },
  {
    "title": "Metricas",
    "page": 40,
    "text": "Conforme aumenta el valor de cada una de\nestas complejidades, la complejidad\narquitect√≥nica global del sistema tambi√©n\naumenta.\nEsto conduce a una mayor probabilidad de que\ntambi√©n aumenten el esfuerzo de integraci√≥n y\nel de pruebas."
  },
  {
    "title": "Metricas",
    "page": 41,
    "text": "Del dise√±o orientado a objetos Tres grupos\nde m√©tricas orientadas a objetos\nÔÉºM√©tricas orientadas a la clase (CK).\nÔÉºM√©tricas orientadas a la clase (MOOD) .\nÔÉºM√©tricas de Lorenz y Kidd."
  },
  {
    "title": "Metricas",
    "page": 42,
    "text": "M√©tricas orientadas a clase: la suite de\nm√©tricas CK\n‚Ä¢ Chidamber y Kemerer (CK) propusieron uno de\nlos conjuntos de m√©tricas de software OO de\nmayor referencia.\n‚Ä¢ Los autores proponen seis m√©tricas de dise√±o\nbasadas en clase para sistemas OO.\n‚Ä¢ En ocasiones el simple valor que se obtiene para\nuna m√©trica o la comparaci√≥n de una misma\nm√©trica para dos sistemas distintos permite\nhacernos una idea de su nivel de calidad."
  },
  {
    "title": "Metricas",
    "page": 43,
    "text": "1. M√©todos ponderados por clase (MPC)\n1. Clase con ùëõ m√©todos, de complejidad ùëê1, ‚Ä¶ , ùëêùëõ . La complejidad se mide con alguna\nm√©trica elegida.\n2. ùëÄùëÉùê∂ =\n‚àë(cid:3041)\nùê∂ùëñ\n(cid:3036)(cid:2880)(cid:2869)\n2. Profundidad del √°rbol de herencia (PAH)\n1. Conforme crece la PAH, es probable que las clases de nivel inferior hereden muchos\nm√©todos. Esto conduce a potenciales dificultades cuando se intenta predecir el\ncomportamiento de una clase y conduce a mayor complejidad de dise√±o.\n2. Grandes valores de PAH implican que muchos m√©todos pueden reutilizarse.\n3. N√∫mero de hijos (NDH)\n1. Conforme crece el numero de hijos, el reuso aumenta y la cantidad de pruebas\n(requeridas para ejercitar cada hijo en su contexto operativo) tambi√©n aumentara.\n4. Acoplamiento entre clases de objetos (ACO)\n1. Valores altos co"
  },
  {
    "title": "Metricas",
    "page": 43,
    "text": " de hijos, el reuso aumenta y la cantidad de pruebas\n(requeridas para ejercitar cada hijo en su contexto operativo) tambi√©n aumentara.\n4. Acoplamiento entre clases de objetos (ACO)\n1. Valores altos complican las modificaciones y las pruebas . En general, los valores de\nACO para cada clase deben mantenerse tan bajos como sea razonable.\n5. Respuesta para una clase (RPC): es un conjunto de m√©todos que potencialmente pueden\nejecutarse en respuesta a un mensaje recibido por un objeto de dicha clase. Conforme aumenta\nla RPC, tambi√©n los esfuerzos de las pruebas y la complejidad del dise√±o global de la clase.\n6. Falta de cohesi√≥n en m√©todos (FCOM): es el numero de m√©todos que acceden a uno o mas de\nlos mismos atributos. Si hay 6 m√©todos y 4 de ellos acceden a atributos comunes, FCOM = 4. Si\nningu"
  },
  {
    "title": "Metricas",
    "page": 43,
    "text": "la clase.\n6. Falta de cohesi√≥n en m√©todos (FCOM): es el numero de m√©todos que acceden a uno o mas de\nlos mismos atributos. Si hay 6 m√©todos y 4 de ellos acceden a atributos comunes, FCOM = 4. Si\nninguno accede FCOM = 0. Es deseable mantener baja la FCOM."
  },
  {
    "title": "Metricas",
    "page": 44,
    "text": "M√©tricas orientadas a clase: La suite\nde m√©tricas MOOD\n‚Ä¢ Factor de herencia de m√©todo (FHM)\n‚Äì El grado en el que la arquitectura de clase de un\nsistema OO utiliza la herencia tanto para m√©todos\ncomo para atributos.\n‚Äì Ofrece un indicio del impacto de la herencia sobre\nel software OO.\n‚Ä¢ Factor de acoplamiento (FA)\n‚Äì Conforme el valor de FA aumenta, la complejidad\ndel software OO tambien aumentara"
  },
  {
    "title": "Metricas",
    "page": 45,
    "text": "M√©tricas OO propuestas por Lorenz y\nKidd\n‚Ä¢ Dividen las m√©tricas basadas en clase en\ncuatro amplias categor√≠as; cada una tiene una\nrelaci√≥n en el dise√±o en el nivel de\ncomponentes:\n‚Äì Tama√±o, herencia, internos y externos"
  },
  {
    "title": "Metricas",
    "page": 46,
    "text": "M√©tricas OO propuestas por Lorenz y\nKidd\nMM√©√©ttrriiccaass MM√©√©ttrriiccaass\nTTaammaa√±√±oo ddee\nHHeerreenncciiaa iinntteerrnnaass ddee eexxtteerrnnaass ddee\nuunnaa ccllaassee\nccllaassee ccllaassee\nSe enfocan en\nconteos de Se enfocan en\natributos y la forma en la se enfocan en\noperaciones que las la cohesi√≥n y\nExaminan el\npara una clase operaciones en los\nacoplamiento\nindividual y en se reutilizan a conflictos\ny el reuso.\nvalores lo largo de la orientados a\npromedio para jerarqu√≠a de c√≥digo.\nel sistema OO clases.\ncomo un todo."
  },
  {
    "title": "Metricas",
    "page": 47,
    "text": "M√©tricas de dise√±o en el nivel de\ncomponente\n‚Ä¢ Se enfocan en las caracter√≠sticas internas de un\ncomponente de software e incluyen medidas\nde cohesi√≥n de m√≥dulo, acoplamiento y\ncomplejidad"
  },
  {
    "title": "Metricas",
    "page": 48,
    "text": "M√©tricas orientadas a operaci√≥n\n(m√©todos)\n‚Ä¢ Tama√±o promedio de operaci√≥n (TOprom). El tama√±o\npuede determinarse al contar el n√∫mero de l√≠neas de\nc√≥digo o el de mensajes enviados por el m√©todo. Conforme\naumenta el n√∫mero de mensajes enviados por un solo\nm√©todo, es probable que las responsabilidades no se hayan\nasignado bien dentro de una clase.\n‚Ä¢ Complejidad de la operaci√≥n (CO). Los m√©todos deben\nlimitarse a una responsabilidad espec√≠fica, el dise√±ador\ndebe luchar por mantener la CO tan baja como sea posible.\n‚Ä¢ N√∫mero promedio de par√°metros por operaci√≥n\n(NPprom). Mientras m√°s grande sea el n√∫mero de\npar√°metros del m√©todo, m√°s compleja es la colaboraci√≥n\nentre objetos. En general, el NPprom debe mantenerse tan\nbajo como sea posible."
  },
  {
    "title": "Metricas",
    "page": 49,
    "text": "M√©tricas de dise√±o de interfaz de\nusuario\n‚Ä¢ ‚ÄúLa correcta distribuci√≥n de objetos visuales‚Äù\n‚Äì Posici√≥n de las entidades (gr√°ficos, √≠conos, textos,\nmen√∫s, ventanas, etc.) en la distribuci√≥n de la\npantalla.\n‚Äì Frecuencia con la que se usa\n‚Äì La dificultad para moverse de una entidad a otra"
  },
  {
    "title": "Metricas",
    "page": 50,
    "text": "M√©tricas de usabilidad y UX\nLos usuarios experimentan e interact√∫an con el software de diferentes formas. As√≠\ncomo es dif√≠cil clasificar las emociones de las personas, tambi√©n es un desaf√≠o evaluar\nsu reacci√≥n al software. Si bien ninguna m√©trica de software puede comunicar la\ntotalidad de la experiencia de usuario, hay algunas que son √∫tiles.\n‚Ä¢ M√©tricas de UX. Las mediciones de UX suelen ser cualitativas y pueden incluir las\nrespuestas emocionales o corporales de los usuarios, como cu√°nto conf√≠an en el\nsoftware y c√≥mo se mueven sus ojos a trav√©s de una interfaz de usuario.\n‚Ä¢ M√©tricas de usabilidad. La usabilidad mide qu√© tan bien el software permite a los\nclientes alcanzar sus objetivos. La usabilidad se puede dividir en componentes m√°s\npeque√±os, como los siguientes:\nFacilidad de descubri"
  },
  {
    "title": "Metricas",
    "page": 50,
    "text": "lidad. La usabilidad mide qu√© tan bien el software permite a los\nclientes alcanzar sus objetivos. La usabilidad se puede dividir en componentes m√°s\npeque√±os, como los siguientes:\nFacilidad de descubrimiento - eficiencia ‚Äì memorabilidad - facilidad de aprendizaje ‚Äì\nsatisfacci√≥n - accesibilidad, particularmente accesibilidad digital\n‚Ä¢ Net Promoter Score (NPS). Refleja la voluntad de los clientes de recomendar una\naplicaci√≥n a otros. Net Promoter Score - Puntuaci√≥n neta del promotor - se\npresenta como un rango de n√∫meros de 0 a 10. Los clientes con una puntuaci√≥n de\n0 a 6 son Detractores; las puntuaciones 7 y 8 son Pasivos; y 9 y 10 son Promotores."
  },
  {
    "title": "Metricas",
    "page": 50,
    "text": "tuaciones 7 y 8 son Pasivos; y 9 y 10 son Promotores."
  },
  {
    "title": "Metricas",
    "page": 51,
    "text": "M√©tricas para el modelo de\nimplementaci√≥n\nM√âTRICAS PARA C√ìDIGO FUENTE"
  },
  {
    "title": "Metricas",
    "page": 52,
    "text": "Halstead asign√≥ leyes cuantitativas al desarrollo de\nsoftware usando un conjunto de medidas primitivas\nque pueden derivarse despu√©s de generar el c√≥digo\no de que el dise√±o este completo. Las medidas son:\n‚Ä¢ n1 = numero de operadores distintos en un\nprograma.\n‚Ä¢ n2 = numero de operandos distintos en un\nprograma\n‚Ä¢ N1 = numero total de ocurrencias de operador\n‚Ä¢ N2 = numero total de ocurrencias de operando"
  },
  {
    "title": "Metricas",
    "page": 53,
    "text": "Usos\n‚Ä¢ Longitud de programa global, N = n log (n )+ n log (n )\n1 2 1 2 2 2\n‚Ä¢ volumen m√≠nimo potencial para un algoritmo, V = N log (n + n )\n2 1 2\n‚Ä¢ volumen real (numero de bits requeridos para especificar un\nprograma),\n‚Ä¢ nivel del programa (una medida de complejidad del software),\n‚Ä¢ nivel del lenguaje (una constante para un lenguaje determinado),\nesfuerzo de desarrollo, tiempo de desarrollo e incluso el numero\nproyectado de fallas en el software.\nSe utiliza en herramientas como IBM¬Æ Application Discovery and\nDelivery Intelligence (ADDI) es una plataforma anal√≠tica para la\nmodernizaci√≥n de las aplicaciones. Utiliza tecnolog√≠as cognitivas para\nanalizar aplicaciones de mainframe y descubrir y comprender\nr√°pidamente las interdependencias de los cambios.\nSonarQube para diversos lenguajes de pro"
  },
  {
    "title": "Metricas",
    "page": 53,
    "text": "aplicaciones. Utiliza tecnolog√≠as cognitivas para\nanalizar aplicaciones de mainframe y descubrir y comprender\nr√°pidamente las interdependencias de los cambios.\nSonarQube para diversos lenguajes de programaci√≥n."
  },
  {
    "title": "Metricas",
    "page": 54,
    "text": "Ejemplo para calcular las medidas de Halstead.\nCalcular las medidas de Halstead de longitud y esfuerzo para el\nsiguiente algoritmo:\n{ El n√∫mero total de operadores (n1) son 10 y la cantidad\nfor (i=2;i<=n;i++) de operadores (N1) que hay son 23:\nfor (j=1;j<=i;j++)\nif (x[i]<x[j]) 2 {..} + 2 for(;;) + 5 = + 1 if + 3 ; + 1 (..) + 1 < + 2 <= + 2 ++\n{ 4 []\naux = x[i];\nx[i] = x[j]; El n√∫mero total de operandos (n2) son 5 y la cantidad\nx[j] = aux; total (N2) son 22.\n} 7 i + 1 n + 6 j + 6 x + 2 aux\n}\nLa longitud es N = N1 + N2 = 23 + 22 = 45\nN es una simple medida del tama√±o de un programa. Cuanto m√°s grande sea el\ntama√±o de N, mayor ser√° la dificultad para comprender el programa y mayor el\nesfuerzo para mantenerlo."
  },
  {
    "title": "Metricas",
    "page": 55,
    "text": "El volumen es V = N x log2(n)\n= 45 x log2 (10+5)\n= 175.8\n(nro. m√≠nimo de bits necesarios para codificar el programa)\n‚Ä¢ El esfuerzo es una medida del trabajo requerido para\ndesarrollar un programa. Desde el punto de vista del\nmantenimiento, el esfuerzo se puede interpretar como\nuna medida del trabajo requerido para comprender un\nsoftware ya desarrollado. Cuanto menor es su valor, m√°s\nf√°cil ser√° modificar el programa:\n‚Ä¢ E= V * 1/L = V*(n1/2)*(N2/n2)=175,8*(5)*(22/5) = 3867,6\n‚Ä¢ Tiempo de entendimiento o implementaci√≥n:\nT=E/18= 214,87 segundos."
  },
  {
    "title": "Metricas",
    "page": 56,
    "text": "M√âTRICAS PARA PRUEBAS"
  },
  {
    "title": "Metricas",
    "page": 57,
    "text": "M√©tricas de Halstead M√©tricas para pruebas\naplicadas para probar orientadas a objetos\nEl esfuerzo de prueba\npuede estimarse usando\nm√©tricas derivadas de las\nmedidas de Halstead.\nLas m√©tricas consideran\nEl esfuerzo de un\naspectos de\nm√≥dulo/ la suma de\nencapsulaci√≥n y\nesfuerzo de todos los\nherencia.\nm√≥dulos del sistema."
  },
  {
    "title": "Metricas",
    "page": 58,
    "text": "M√âTRICAS PARA\nMANTENIMIENTO"
  },
  {
    "title": "Metricas",
    "page": 59,
    "text": "‚Ä¢ Todas las m√©tricas de software presentadas\nanteriormente pueden usarse para el\ndesarrollo de nuevo software y para el\nmantenimiento del software existente.\n‚Ä¢ Sin embargo, se han propuesto m√©tricas\ndise√±adas expl√≠citamente para actividades de\nmantenimiento."
  },
  {
    "title": "Metricas",
    "page": 60,
    "text": "√çndice de madurez de software (IMS)\n‚Ä¢ Proporciona un indicio de la estabilidad de un\nproducto de software (con base en cambios que\nocurran para cada versi√≥n del producto).\n‚Ä¢ Conforme el IMS tiende a 1, el producto comienza a\nestabilizarse"
  }
]